This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.env.example
.github/copilot-instructions.md
.github/workflows/deploy.yml
.gitignore
.prettierrc
app/auth/layout.tsx
app/auth/login/page.tsx
app/auth/register/page.tsx
app/create/page.tsx
app/error.tsx
app/favicon.ico
app/gallery/page.tsx
app/layout.tsx
app/page.tsx
components.json
docker-compose.yml
Dockerfile
eslint.config.mjs
middleware.ts
next.config.ts
package.json
pages/README.md
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
reactuse.json
README.md
src/app/globals.css
src/app/providers.tsx
src/entities/meme/index.ts
src/entities/meme/model/dto.ts
src/entities/meme/model/queries.ts
src/entities/meme/model/types.ts
src/entities/meme/ui/index.ts
src/entities/meme/ui/MemeCard.tsx
src/entities/user/api/useGetUser.ts
src/entities/user/api/useLogoutUser.ts
src/entities/user/index.ts
src/features/create-meme/index.ts
src/features/create-meme/model/mutations.ts
src/features/create-meme/model/schema.ts
src/features/create-meme/ui/CreateMemeForm.tsx
src/features/search-memes/index.ts
src/features/search-memes/ui/SearchInput.tsx
src/lib/index.ts
src/lib/isTarget.ts
src/pages/create-meme/index.ts
src/pages/create-meme/ui/CreateMemePage.tsx
src/pages/gallery/api/index.ts
src/pages/gallery/config/index.ts
src/pages/gallery/index.ts
src/pages/gallery/model/index.ts
src/pages/gallery/ui/Gallery.tsx
src/pages/gallery/ui/index.ts
src/pages/home/index.ts
src/pages/home/ui/HomePage.tsx
src/pages/login/api/useLogin.ts
src/pages/login/index.ts
src/pages/login/model/login.model.ts
src/pages/login/ui/LoginPage.tsx
src/pages/register/api/useRegister.ts
src/pages/register/index.ts
src/pages/register/model/register.model.ts
src/pages/register/ui/RegisterPage.tsx
src/shared/api/api-schema.d.ts
src/shared/api/client.ts
src/shared/api/config.ts
src/shared/api/hooks.ts
src/shared/api/index.ts
src/shared/api/memes.ts
src/shared/api/typed-client.ts
src/shared/api/user/auth.ts
src/shared/api/user/users.ts
src/shared/config/env.ts
src/shared/config/index.js
src/shared/config/routes.ts
src/shared/hooks/index.ts
src/shared/hooks/use-intersection-observer.ts
src/shared/hooks/use-mobile.ts
src/shared/hooks/useElementSize/useElementSize.ts
src/shared/hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.ts
src/shared/hooks/useRefState/useRefState.ts
src/shared/hooks/useWindowSize/useWindowSize.ts
src/shared/lib/getElement.ts
src/shared/lib/group-by-date.ts
src/shared/lib/search-params.ts
src/shared/lib/utils.ts
src/shared/lib/utils/index.ts
src/shared/lib/utils/isTarget.ts
src/shared/types/index.js
src/shared/ui/authCard.tsx
src/shared/ui/avatar.tsx
src/shared/ui/badge.tsx
src/shared/ui/button.tsx
src/shared/ui/card.tsx
src/shared/ui/checkbox.tsx
src/shared/ui/field.tsx
src/shared/ui/input.tsx
src/shared/ui/inputLabel.tsx
src/shared/ui/label.tsx
src/shared/ui/logo.tsx
src/shared/ui/scroll-area.tsx
src/shared/ui/select.tsx
src/shared/ui/separator.tsx
src/shared/ui/sheet.tsx
src/shared/ui/sidebar.tsx
src/shared/ui/skeleton.tsx
src/shared/ui/sonner.tsx
src/shared/ui/tooltip.tsx
src/widgets/app-sidebar/index.ts
src/widgets/app-sidebar/ui/AppSidebar.tsx
src/widgets/app-sidebar/ui/ThemeToggle.tsx
src/widgets/app-sidebar/ui/UserWidget.tsx
src/widgets/auth-layout/AuthLayout.tsx
src/widgets/auth-layout/index.ts
src/widgets/meme-gallery/index.ts
src/widgets/meme-gallery/ui/MemeGallery.tsx
src/widgets/memes-list/index.ts
src/widgets/memes-list/ui/cards-skeleton.tsx
src/widgets/memes-list/ui/MemeCard.tsx
src/widgets/memes-list/ui/MemesList.tsx
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
# Dependencies
node_modules
npm-debug.log
yarn-error.log
.pnpm-debug.log
bun.lockb

# Next.js
.next
out
dist
build

# Environment files (будут прокинуты через docker-compose)
.env
.env.local
.env.development
.env.test
.env.production
.env*.local

# Testing
coverage
.nyc_output

# IDEs
.idea
.vscode
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore
.gitattributes

# Documentation
README.md
CHANGELOG.md
LICENSE
*.md
docs

# Docker
Dockerfile
.dockerignore
docker-compose*.yml

# CI/CD
.github
.gitlab-ci.yml
.travis.yml

# Misc
.prettierrc
.eslintrc
.editorconfig
</file>

<file path=".github/workflows/deploy.yml">
name: Frontend MemoLogy Auto-Deploy

on:
    push:
        branches:
            - main

jobs:
    deploy:
        name: Deploy Frontend to Server
        runs-on: ubuntu-latest
        steps:
            - name: Deploy to Server
              uses: appleboy/ssh-action@master
              with:
                  host: ${{ secrets.SERVER_HOST }}
                  username: ${{ secrets.SERVER_USER }}
                  key: ${{ secrets.SSH_PRIVATE_KEY }}
                  script: |
                      set -e

                      if [ ! -d "$HOME/memology-frontend" ]; then
                        cd $HOME
                        git clone https://github.com/Tomato1337/memology-frontend.git
                      fi

                      cd $HOME/memology-frontend
                      git fetch origin main
                      git reset --hard origin/main
                      docker compose down
                      docker compose build
                      docker compose up -d
</file>

<file path=".prettierrc">
{
	"singleQuote": false,
	"trailingComma": "all",
	"arrowParens": "always",
	"useTabs": true,
	"tabWidth": 4,
	"semi": false,
	"plugins": ["prettier-plugin-tailwindcss"]
}
</file>

<file path="app/auth/login/page.tsx">
import LoginPage from "@/pages/login"

export default function Page() {
	return <LoginPage />
}
</file>

<file path="app/auth/register/page.tsx">
import RegisterPage from "@/pages/register"

export default function Page() {
	return <RegisterPage />
}
</file>

<file path="app/create/page.tsx">
// Next.js App Router page - thin wrapper over FSD structure
import CreateMemePage from "@/pages/create-meme"

export const metadata = {
	title: "Создать мем - AI Meme Generator",
	description: "Создавай уникальные мемы с помощью искусственного интеллекта",
}

export default function CreatePage() {
	return <CreateMemePage />
}
</file>

<file path="app/error.tsx">
"use client"

export default function Error() {
	return <div>Error</div>
}
</file>

<file path="app/gallery/page.tsx">
import React from "react"
import { GalleryPage } from "@/pages/gallery"

const Gallery = () => {
	return <GalleryPage />
}

export default Gallery
</file>

<file path="app/page.tsx">
// Next.js App Router page - thin wrapper over FSD structure
import HomePage, { metadata } from "@/pages/home"
import type { SearchParams } from "nuqs/server"

// Re-export metadata for Next.js
export { metadata }

export default async function Page({
	searchParams,
}: {
	searchParams: Promise<SearchParams>
}) {
	return <HomePage searchParams={searchParams} />
}
</file>

<file path="pages/README.md">
Папка, чтобы Next.js игнорировал папку src/pages при сборке проекта.
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/entities/meme/model/dto.ts">
import { components } from "@/shared/api"
import { IMemeDTO, IMemeListDTO } from "./types"

type ApiMeme = components["schemas"]["models.Meme"]
type ApiMemesList = components["schemas"]["handlers.MemeHistoryResponse"]

export class MemeDTO {
	static fromApi(apiMeme: ApiMeme): IMemeDTO {
		return {
			id: apiMeme.id ?? "",
			title: apiMeme.prompt ?? "Untitled",
			imageUrl: apiMeme.image_url ?? "",
			author: apiMeme.user_id ?? "",
			style: apiMeme.style ?? "",
			status: (apiMeme.status ?? "").toLowerCase(),
			likes: apiMeme.metrics?.rating_score ?? 0,
			views: apiMeme.metrics?.click_count ?? 0,
			width: apiMeme.width ?? 300,
			height: apiMeme.height ?? 400,
			createdAt: apiMeme.created_at ?? new Date().toISOString(),
			updatedAt: apiMeme.updated_at ?? new Date().toISOString(),
			downloadCount: apiMeme.metrics?.download_count ?? 0,
			otherInteractions: apiMeme.metrics?.other_interactions ?? 0,
		}
	}
}

export class MemesListDTO {
	static fromApi(apiMemes: ApiMemesList): IMemeListDTO {
		return {
			data: apiMemes.memes?.map((meme) => MemeDTO.fromApi(meme)) ?? [],
			total: apiMemes.total ?? 0,
			page: apiMemes.page ?? 1,
			limit: apiMemes.limit ?? 30,
		}
	}
}
</file>

<file path="src/entities/meme/model/queries.ts">
import { useQuery, useInfiniteQuery } from "@tanstack/react-query"
import {
	getMyMemes,
	getMemeStatus,
	getAvailableStyles,
} from "@/shared/api/memes"
import { MemesListDTO } from "./dto"
import type { IMemeListDTO } from "./types"

export const memeKeys = {
	all: ["memes"] as const,
	my: () => [...memeKeys.all, "my"] as const,
	styles: () => [...memeKeys.all, "styles"] as const,
	status: (id: string) => [...memeKeys.all, "status", id] as const,
}

export function useMyMemesInfinite(limit = 20) {
	return useInfiniteQuery<IMemeListDTO>({
		queryKey: memeKeys.my(),
		queryFn: async ({ pageParam = 0 }) => {
			const data = await getMyMemes({
				limit,
				offset: (pageParam as number) * limit,
			})
			return MemesListDTO.fromApi(data)
		},
		initialPageParam: 0,
		getNextPageParam: (lastPage, allPages) => {
			const totalFetched = allPages.reduce(
				(acc, page) => acc + page.data.length,
				0,
			)
			if (totalFetched >= lastPage.total) return undefined
			return allPages.length
		},
	})
}

export function useMemeStyles() {
	return useQuery({
		queryKey: memeKeys.styles(),
		queryFn: getAvailableStyles,
		staleTime: 1000 * 60 * 5, // 5 минут
	})
}

export function useMemeStatus(id: string, enabled = false) {
	return useQuery({
		queryKey: memeKeys.status(id),
		queryFn: () => getMemeStatus(id),
		enabled,
		refetchInterval: (query) => {
			const meme = query.state.data
			if (meme?.status === "completed" || meme?.status === "failed") {
				return false
			}
			return 2000 // Poll every 2s
		},
	})
}
</file>

<file path="src/entities/meme/model/types.ts">
import type { components } from "@/shared/api/api-schema"

// Тип статуса мема
export type MemeStatus = "pending" | "processing" | "completed" | "failed"

// Запрос на создание мема
export type CreateMemeRequest =
	components["schemas"]["services.CreateMemeRequest"]

export interface IMemeDTO {
	id: string
	title: string
	imageUrl: string
	author: string
	style: string
	status: string
	likes: number
	views: number
	width: number
	height: number
	createdAt: string
	updatedAt: string
	downloadCount: number
	otherInteractions: number
}

export interface IMemeListDTO {
	data: IMemeDTO[]
	total: number
	page: number
	limit: number
}
export type MemeListResponse =
	components["schemas"]["handlers.MemeHistoryResponse"]

export interface CreateMemeDto {
	title: string
	imageUrl: string
	description?: string
	tags?: string[]
}

export interface UpdateMemeDto {
	title?: string
	description?: string
	tags?: string[]
}

export interface GenerateMemeDto {
	user_input: string
	style?: string
}
</file>

<file path="src/entities/meme/ui/index.ts">
export { MemeCard } from "./MemeCard"
</file>

<file path="src/entities/user/index.ts">
import { useGetUser } from "./api/useGetUser"
import { useLogoutUser } from "./api/useLogoutUser"

export const userQueries = {
	useGetUser,
	useLogoutUser,
}
</file>

<file path="src/features/create-meme/index.ts">
export { CreateMemeForm } from "./ui/CreateMemeForm"
export { useGenerateMeme } from "./model/mutations"
export type { CreateMemeFormData } from "./model/schema"
</file>

<file path="src/features/create-meme/model/mutations.ts">
import { useMutation, useQueryClient } from "@tanstack/react-query"
import { generateMeme } from "@/shared/api/memes"
import { memeKeys } from "@/entities/meme"
import type { CreateMemeFormData } from "./schema"

export function useGenerateMeme() {
	const queryClient = useQueryClient()

	return useMutation({
		mutationFn: (data: CreateMemeFormData) => generateMeme(data),
		onSuccess: () => {
			// Invalidate user memes to refetch the list
			queryClient.invalidateQueries({
				queryKey: memeKeys.my(),
			})
		},
	})
}
</file>

<file path="src/features/create-meme/model/schema.ts">
import { z } from "zod"

export const createMemeSchema = z.object({
	prompt: z
		.string()
		.min(1, "Введите текст для мема")
		.max(500, "Максимум 500 символов"),
	style: z.string().optional(),
	is_public: z.boolean(),
})

export type CreateMemeFormData = z.infer<typeof createMemeSchema>
</file>

<file path="src/features/create-meme/ui/CreateMemeForm.tsx">
"use client"

import { useState, useEffect } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { useGenerateMeme } from "../model/mutations"
import { createMemeSchema, type CreateMemeFormData } from "../model/schema"
import { useMemeStyles, useMemeStatus, memeKeys } from "@/entities/meme"
import { Button } from "@/shared/ui/button"
import { Input } from "@/shared/ui/input"
import { Label } from "@/shared/ui/label"
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@/shared/ui/select"
import { Card, CardContent, CardHeader, CardTitle } from "@/shared/ui/card"
import { Checkbox } from "@/shared/ui/checkbox"
import { toast } from "sonner"
import { Loader2 } from "lucide-react"
import Image from "next/image"
import { useQueryClient } from "@tanstack/react-query"

export function CreateMemeForm() {
	const [generatedMemeId, setGeneratedMemeId] = useState<string | null>(null)
	const queryClient = useQueryClient()

	// Fetches
	const { data: styles, isLoading: stylesLoading } = useMemeStyles()

	// Mutations
	const { mutate: generate, isPending: isGenerating } = useGenerateMeme()

	const MEME_GENERATION_ID_KEY = "meme_generation_id"

	// Restore from localStorage on mount
	useEffect(() => {
		const savedId = localStorage.getItem(MEME_GENERATION_ID_KEY)
		if (savedId) {
			setGeneratedMemeId(savedId)
		}
	}, [])

	// Save to localStorage when ID changes
	useEffect(() => {
		if (generatedMemeId) {
			localStorage.setItem(MEME_GENERATION_ID_KEY, generatedMemeId)
		} else {
			localStorage.removeItem(MEME_GENERATION_ID_KEY)
		}
	}, [generatedMemeId])

	// Status polling (only when meme is generated)
	const {
		data: generatedMeme,
		isLoading: isPolling,
		isError: isPollingError,
	} = useMemeStatus(generatedMemeId || "", !!generatedMemeId)

	// Handle polling errors (e.g. 404 if ID is invalid/expired)
	useEffect(() => {
		if (isPollingError) {
			setGeneratedMemeId(null)
			localStorage.removeItem(MEME_GENERATION_ID_KEY)
			toast.error("Не удалось восстановить статус генерации")
		}
	}, [isPollingError])

	// React Hook Form
	const {
		register,
		handleSubmit,
		setValue,
		watch,
		formState: { errors },
		reset,
	} = useForm<CreateMemeFormData>({
		resolver: zodResolver(createMemeSchema),
		defaultValues: {
			prompt: "",
			style: undefined,
			is_public: true,
		},
	})

	const selectedStyle = watch("style")
	const isPublic = watch("is_public")

	// Submit handler
	const onSubmit = (data: CreateMemeFormData) => {
		const payload = {
			...data,
			style: data.style || undefined,
		}

		generate(payload, {
			onSuccess: (meme) => {
				toast.success("Генерация начата!")
				setGeneratedMemeId(meme.id || null)
			},
			onError: (error) => {
				toast.error("Ошибка генерации: " + error.message)
			},
		})
	}

	// Reset when meme is completed
	useEffect(() => {
		if (generatedMeme?.status === "completed") {
			toast.success("Мем успешно создан!")
			setGeneratedMemeId(null)
			queryClient.invalidateQueries({
				queryKey: memeKeys.my(),
			})
			reset()
		} else if (generatedMeme?.status === "failed") {
			toast.error("Ошибка при генерации мема")
			setGeneratedMemeId(null)
		}
	}, [generatedMeme?.status, reset, queryClient])

	const isLoading = isGenerating || isPolling

	return (
		<Card className="w-full">
			<CardContent>
				<form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
					<div className="space-y-2">
						<Label htmlFor="prompt">Текст мема</Label>
						<Input
							id="prompt"
							{...register("prompt")}
							placeholder="Введите текст для мема..."
							disabled={isLoading}
							className="font-montserrat"
						/>
						{errors.prompt && (
							<p className="text-destructive text-sm">
								{errors.prompt.message}
							</p>
						)}
					</div>

					<div className="space-y-2">
						<Label htmlFor="style">Стиль (опционально)</Label>
						<Select
							value={selectedStyle}
							onValueChange={(value) => setValue("style", value)}
							disabled={isLoading || stylesLoading}
						>
							<SelectTrigger id="style">
								<SelectValue placeholder="Выберите стиль" />
							</SelectTrigger>
							<SelectContent>
								{styles?.map((style) => (
									<SelectItem key={style} value={style}>
										{style}
									</SelectItem>
								))}
							</SelectContent>
						</Select>
					</div>

					<div className="flex items-center space-x-2">
						<Checkbox
							id="is_public"
							checked={isPublic}
							onCheckedChange={(checked) =>
								setValue("is_public", Boolean(checked))
							}
							disabled={isLoading}
						/>
						<Label
							htmlFor="is_public"
							className="text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
						>
							Публичный мем
						</Label>
					</div>

					<Button
						type="submit"
						disabled={isLoading || !!generatedMemeId}
						className="font-pixelify w-full cursor-pointer"
					>
						{isLoading ? (
							<>
								<Loader2 className="mr-2 h-4 w-4 animate-spin" />
								{isPolling ? "Создаём мем..." : "Отправка..."}
							</>
						) : (
							"Создать мем"
						)}
					</Button>

					{generatedMeme &&
						generatedMeme.image_url &&
						generatedMeme.status === "completed" && (
							<div className="mt-6 space-y-4">
								<h3 className="font-pixelify text-lg">
									Результат:
								</h3>
								<div className="relative aspect-square w-full overflow-hidden rounded-lg border">
									<Image
										src={generatedMeme.image_url}
										alt="Сгенерированный мем"
										fill
										className="object-cover"
									/>
								</div>
							</div>
						)}
				</form>
			</CardContent>
		</Card>
	)
}
</file>

<file path="src/features/search-memes/index.ts">
// Public API for search-memes feature (FSD pattern)
export { SearchInput } from "./ui/SearchInput"
</file>

<file path="src/lib/index.ts">
export * from './isTarget';
</file>

<file path="src/lib/isTarget.ts">
import type { RefObject } from 'react';

export const targetSymbol = Symbol('target');

export type Target = (() => Element) | string | Document | Element | Window;

export type HookTarget =
  | RefObject<Element | null | undefined>
  | {
      value: Target;
      type: symbol;
    };

const getElement = (target: HookTarget) => {
  if ('current' in target) {
    return target.current;
  }

  if (typeof target.value === 'function') {
    return target.value();
  }

  if (typeof target.value === 'string') {
    return document.querySelector(target.value);
  }

  if (target.value instanceof Document) {
    return target.value;
  }

  if (target.value instanceof Window) {
    return target.value;
  }

  if (target.value instanceof Element) {
    return target.value;
  }

  return target.value;
};

export const target = (target: Target) => ({
  value: target,
  type: targetSymbol
});

export const isTarget = (target: HookTarget) =>
  typeof target === 'object' &&
  ('current' in target || (target && (target as any).type === targetSymbol));

isTarget.wrap = target;
isTarget.getElement = getElement;
</file>

<file path="src/pages/create-meme/index.ts">
export { default } from "./ui/CreateMemePage"
</file>

<file path="src/pages/create-meme/ui/CreateMemePage.tsx">
"use client"

import { CreateMemeForm } from "@/features/create-meme"
import { MemeGallery } from "@/widgets/meme-gallery"
import { SidebarTrigger } from "@/shared/ui/sidebar"
import { Button } from "@/shared/ui/button"
import { PlusCircle } from "lucide-react"
import Link from "next/link"
import { SearchInput } from "@/features/search-memes"

export default function CreateMemePage() {
	return (
		<div className="bg-background min-h-screen">
			<header className="bg-background sticky top-0 z-10 flex items-center gap-4 border-b p-2">
				<SidebarTrigger className="size-12" />
				<h2 className="font-pixelify-sans text-2xl font-light">
					Создание мемов
				</h2>
			</header>
			<main className="bg-background relative mt-2 flex-1 overflow-hidden px-4">
				<div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
					<div className="order-1">
						<CreateMemeForm />
					</div>
					<div className="order-2">
						<MemeGallery />
					</div>
				</div>
			</main>
		</div>
	)
}
</file>

<file path="src/pages/gallery/api/index.ts">
export { }
</file>

<file path="src/pages/gallery/config/index.ts">
export { }
</file>

<file path="src/pages/gallery/index.ts">
export * from './api'
export * from './config'
export * from './model'
export * from './ui'
</file>

<file path="src/pages/gallery/model/index.ts">
export { }
</file>

<file path="src/pages/gallery/ui/Gallery.tsx">
import { SidebarTrigger } from "@/shared/ui/sidebar"
import { MemeGallery } from "@/widgets/meme-gallery"

export default function GalleryPage() {
	return (
		<div className="bg-background min-h-screen">
			<header className="bg-background sticky top-0 z-10 flex items-center gap-4 border-b p-2">
				<SidebarTrigger className="size-12" />
				<h2 className="font-pixelify-sans text-2xl font-light">
					Галерея
				</h2>
			</header>
			<main className="bg-background relative mt-2 h-[calc(100vh-5rem)] flex-1 overflow-hidden px-4">
				<MemeGallery isGalleryPage={true} />
			</main>
		</div>
	)
}
</file>

<file path="src/pages/gallery/ui/index.ts">
import GalleryPage from "./Gallery"

export { GalleryPage }
</file>

<file path="src/pages/home/index.ts">
export { default, metadata } from "./ui/HomePage"
</file>

<file path="src/pages/login/index.ts">
export { default } from "./ui/LoginPage"
</file>

<file path="src/pages/login/model/login.model.ts">
import z from "zod"

export const loginSchema = z.object({
	emailOrUsername: z.email({ message: "Enter a valid email address" }),
	password: z
		.string()
		.min(6, { message: "Password must be at least 6 characters" }),
})
export type LoginForm = z.infer<typeof loginSchema>
</file>

<file path="src/pages/register/index.ts">
export { default } from "./ui/RegisterPage"
</file>

<file path="src/shared/api/hooks.ts">
/**
 * Пример использования типизированного API с React Query
 *
 * Этот файл демонстрирует паттерны использования API клиента
 * вместе с TanStack Query для кэширования и управления состоянием.
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import {
	getUserProfile,
	updateUserProfile,
	loginUser,
	registerUser,
	getUsersList,
	type UpdateProfileRequest,
	type LoginRequest,
	type RegisterRequest,
} from "@/shared/api"

/**
 * Хук для получения профиля текущего пользователя
 *
 * @example
 * function ProfileComponent() {
 *   const { data: user, isLoading, error } = useUserProfile()
 *
 *   if (isLoading) return <div>Loading...</div>
 *   if (error) return <div>Error: {error.message}</div>
 *   if (!user) return null
 *
 *   return <div>Hello, {user.username}</div>
 * }
 */
export function useUserProfile() {
	return useQuery({
		queryKey: ["user", "profile"],
		queryFn: async () => {
			const { data, error } = await getUserProfile()
			if (error) throw new Error(error.error || "Failed to fetch profile")
			return data
		},
	})
}

/**
 * Хук для получения списка пользователей
 *
 * @example
 * function UsersListComponent() {
 *   const { data: users, isLoading } = useUsersList({ limit: 10, offset: 0 })
 *
 *   if (isLoading) return <div>Loading...</div>
 *
 *   return (
 *     <ul>
 *       {users?.map(user => (
 *         <li key={user.id}>{user.username}</li>
 *       ))}
 *     </ul>
 *   )
 * }
 */
export function useUsersList(params?: { limit?: number; offset?: number }) {
	return useQuery({
		queryKey: ["users", "list", params],
		queryFn: async () => {
			const { data, error } = await getUsersList(params)
			if (error) throw new Error(error.error || "Failed to fetch users")
			return data
		},
	})
}

/**
 * Хук для обновления профиля пользователя
 *
 * @example
 * function UpdateProfileForm() {
 *   const { mutate: updateProfile, isPending } = useUpdateProfile()
 *
 *   const handleSubmit = (formData: UpdateProfileRequest) => {
 *     updateProfile(formData, {
 *       onSuccess: (user) => {
 *         console.log("Profile updated:", user)
 *       },
 *       onError: (error) => {
 *         console.error("Update failed:", error)
 *       }
 *     })
 *   }
 *
 *   return <form onSubmit={...}>...</form>
 * }
 */
export function useUpdateProfile() {
	const queryClient = useQueryClient()

	return useMutation({
		mutationFn: async (data: UpdateProfileRequest) => {
			const { data: user, error } = await updateUserProfile(data)
			if (error)
				throw new Error(error.error || "Failed to update profile")
			return user
		},
		onSuccess: (user) => {
			// Обновляем кэш профиля
			queryClient.setQueryData(["user", "profile"], user)
			// Инвалидируем список пользователей
			queryClient.invalidateQueries({ queryKey: ["users", "list"] })
		},
	})
}

/**
 * Хук для входа в систему
 *
 * @example
 * function LoginForm() {
 *   const { mutate: login, isPending, error } = useLogin()
 *
 *   const handleSubmit = (credentials: LoginRequest) => {
 *     login(credentials, {
 *       onSuccess: (authResponse) => {
 *         console.log("Logged in:", authResponse.user)
 *         // Редирект на главную страницу
 *       }
 *     })
 *   }
 *
 *   return <form onSubmit={...}>...</form>
 * }
 */
export function useLogin() {
	const queryClient = useQueryClient()

	return useMutation({
		mutationFn: async (credentials: LoginRequest) => {
			const { data, error } = await loginUser(credentials)
			if (error) {
				throw new Error(error.error || "Login failed")
			}
			return data
		},
		onSuccess: (authResponse) => {
			// Сохраняем данные пользователя в кэш
			if (authResponse?.user) {
				queryClient.setQueryData(["user", "profile"], authResponse.user)
			}
		},
	})
}

/**
 * Хук для регистрации нового пользователя
 *
 * @example
 * function RegisterForm() {
 *   const { mutate: register, isPending } = useRegister()
 *
 *   const handleSubmit = (formData: RegisterRequest) => {
 *     register(formData, {
 *       onSuccess: (authResponse) => {
 *         console.log("Registered:", authResponse.user)
 *         // Редирект на главную страницу
 *       },
 *       onError: (error) => {
 *         console.error("Registration failed:", error)
 *       }
 *     })
 *   }
 *
 *   return <form onSubmit={...}>...</form>
 * }
 */
export function useRegister() {
	const queryClient = useQueryClient()

	return useMutation({
		mutationFn: async (data: RegisterRequest) => {
			const { data: authResponse, error } = await registerUser(data)
			if (error) {
				throw new Error(error.error || "Registration failed")
			}
			return authResponse
		},
		onSuccess: (authResponse) => {
			// Сохраняем данные пользователя в кэш
			if (authResponse?.user) {
				queryClient.setQueryData(["user", "profile"], authResponse.user)
			}
		},
	})
}

/**
 * Query ключи для удобного управления кэшем
 */
export const queryKeys = {
	user: {
		all: ["user"] as const,
		profile: () => [...queryKeys.user.all, "profile"] as const,
	},
	users: {
		all: ["users"] as const,
		list: (params?: { limit?: number; offset?: number }) =>
			[...queryKeys.users.all, "list", params] as const,
	},
} as const
</file>

<file path="src/shared/api/index.ts">
/**
 * Публичный API для работы с бэкендом
 * Экспортирует типизированные клиенты и функции
 */

// Типизированный клиент на основе openapi-fetch
export { typedApiClient, default as apiTyped } from "./typed-client"

// Legacy клиент (для обратной совместимости)
export { apiClient, apiFetch, ApiError } from "./client"

// API функции для аутентификации
export * from "./user/auth"

// API функции для пользователей
export * from "./user/users"

// React Query хуки
export * from "./hooks"

// API схемы и типы
export type { paths, components } from "./api-schema"
</file>

<file path="src/shared/api/user/users.ts">
/**
 * API функции для работы с пользователями
 * Используют типизированный клиент с автоматической генерацией типов
 */

import { typedApiClient } from "../typed-client"
import type { components } from "../api-schema"

export type User = components["schemas"]["models.User"]
export type UpdateProfileRequest =
	components["schemas"]["services.UpdateProfileRequest"]
export type ChangePasswordRequest =
	components["schemas"]["services.ChangePasswordRequest"]

/**
 * Получить профиль текущего пользователя
 *
 * @example
 * const result = await getUserProfile()
 *
 * if (result.data) {
 *   console.log("User profile:", result.data)
 * } else if (result.error) {
 *   console.error("Failed to get profile:", result.error)
 * }
 */
export async function getUserProfile() {
	return await typedApiClient.GET("/users/profile")
}

/**
 * Обновить профиль текущего пользователя
 *
 * @example
 * const result = await updateUserProfile({
 *   username: "johndoe_new",
 *   email: "john.new@example.com"
 * })
 *
 * if (result.data) {
 *   console.log("Profile updated:", result.data)
 * }
 */
export async function updateUserProfile(data: UpdateProfileRequest) {
	return await typedApiClient.PUT("/users/profile/update", {
		body: data,
	})
}

/**
 * Изменить пароль пользователя
 *
 * @example
 * const result = await changePassword({
 *   current_password: "oldpassword",
 *   new_password: "newpassword123"
 * })
 *
 * if (result.data) {
 *   console.log("Password changed:", result.data.message)
 * }
 */
export async function changePassword(data: ChangePasswordRequest) {
	return await typedApiClient.POST("/users/change-password", {
		body: data,
	})
}

/**
 * Получить список пользователей с пагинацией
 *
 * @example
 * const result = await getUsersList({ limit: 10, offset: 0 })
 *
 * if (result.data) {
 *   console.log("Users list:", result.data)
 * }
 */
export async function getUsersList(params?: {
	limit?: number
	offset?: number
}) {
	return await typedApiClient.GET("/users/list", {
		params: {
			query: params,
		},
	})
}
</file>

<file path="src/shared/hooks/use-intersection-observer.ts">
"use client"

import { useEffect } from "react"

function useIntersectionObserver(
	callback: IntersectionObserverCallback,
	ref: React.RefObject<HTMLElement> | React.RefObject<null> | null,
	config: IntersectionObserverInit = {
		root: null,
		rootMargin: "0px",
		threshold: 0.1,
	},
) {
	useEffect(() => {
		if (ref?.current) {
			const observer = new IntersectionObserver(callback, config)

			observer.observe(ref.current)

			return () => {
				observer.disconnect()
			}
		}
	}, [callback, ref, config])
}

export default useIntersectionObserver
</file>

<file path="src/shared/hooks/use-mobile.ts">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="src/shared/hooks/useElementSize/useElementSize.ts">
import { useState } from "react"

import { HookTarget } from "@/shared/lib/utils/isTarget"

import { isTarget } from "@/shared/lib/utils/isTarget"

import { StateRef } from "../useRefState/useRefState"

import { useIsomorphicLayoutEffect } from "../useIsomorphicLayoutEffect/useIsomorphicLayoutEffect"
import { useRefState } from "../useRefState/useRefState"

/** The element size value type */
export interface UseElementSizeValue {
	/** The element's height */
	height: number
	/** The element's width */
	width: number
}

/** The use element size return type */
export interface UseElementSizeReturn {
	value: UseElementSizeValue
}

export interface UseElementSize {
	(target: HookTarget): UseElementSizeReturn

	<Target extends Element>(
		target?: never,
	): {
		ref: StateRef<Target>
	} & UseElementSizeReturn
}

/**
 * @name useElementSize
 * @description - Hook that observes and returns the width and height of element
 * @category Elements
 * @usage low

 * @overload
 * @param {HookTarget} target The target element to observe
 * @returns {UseElementSizeReturn} An object containing the current width and height of the element
 *
 * @example
 * const { value } = useElementSize(ref);
 *
 * @overload
 * @returns { { ref: StateRef<Target> } & UseElementSizeReturn } An object containing the current width and height of the element
 *
 * @example
 * const { ref, value } = useElementSize();
 */
export const useElementSize = ((...params: any[]) => {
	const target = params[0] as HookTarget | undefined
	const [size, setSize] = useState({ width: 0, height: 0 })
	const internalRef = useRefState<Element>()

	useIsomorphicLayoutEffect(() => {
		const element = (
			target ? isTarget.getElement(target) : internalRef.current
		) as Element

		if (!element) return

		const { width, height } = element.getBoundingClientRect()
		setSize({
			width,
			height,
		})

		const observer = new ResizeObserver(() => {
			const { width, height } = element.getBoundingClientRect()
			setSize({ width, height })
		})

		observer.observe(element)

		return () => {
			observer.disconnect()
		}
	}, [internalRef.current, target])

	if (target) return { value: size }
	return {
		ref: internalRef,
		value: size,
	}
}) as UseElementSize
</file>

<file path="src/shared/hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.ts">
import { useEffect, useLayoutEffect } from 'react';

/**
 * @name useIsomorphicLayoutEffect
 * @description - Hook conditionally selects either `useLayoutEffect` or `useEffect` based on the environment
 * @category Lifecycle
 * @usage high
 *
 * @example
 * useIsomorphicLayoutEffect(() => console.log('effect'), [])
 */
export const useIsomorphicLayoutEffect =
  typeof window !== 'undefined' ? useLayoutEffect : useEffect;
</file>

<file path="src/shared/hooks/useRefState/useRefState.ts">
import { useState } from 'react';

export interface StateRef<Value> {
  (node: Value): void;
  current: Value;
  state?: Value;
}

const createRefState = <Value>(
  initialValue: Value | undefined,
  setState: (value: Value) => void
) => {
  let temp = initialValue;
  function ref(value: Value) {
    if (temp === value) return;
    temp = value;
    setState(temp);
  }

  Object.defineProperty(ref, 'current', {
    get() {
      return temp;
    },
    set(value: Value) {
      if (temp === value) return;
      temp = value;
      setState(temp);
    },
    configurable: true,
    enumerable: true
  });

  return ref as StateRef<Value>;
};

/**
 * @name useRefState
 * @description - Hook that returns the state reference of the value
 * @category State
 * @usage low
 *
 * @template Value The type of the value
 * @param {Value} [initialValue] The initial value
 * @returns {StateRef<Value>} The current value
 *
 * @example
 * const internalRefState = useRefState();
 */
export const useRefState = <Value>(initialValue?: Value) => {
  const [state, setState] = useState<Value | undefined>(initialValue);
  const [ref] = useState(() => createRefState<Value>(initialValue, setState));
  ref.state = state;
  return ref;
};
</file>

<file path="src/shared/hooks/useWindowSize/useWindowSize.ts">
import { useEffect, useState } from 'react';

/** The use window size return type */
interface UseWindowSizeParams {
  /** Whether to include the scrollbar in the window size calculation */
  includeScrollbar?: boolean;
}

/** The use window size return type */
export interface UseWindowSizeReturn {
  /** The current window height */
  height: number;
  /** The current window width */
  width: number;
}

/**
 * @name useWindowSize
 * @description - Hook that manages a window size
 * @category Elements
 * @usage low
 *
 * @param {number} [params.initialWidth=Number.POSITIVE_INFINITY] The initial window width
 * @param {number} [params.initialHeight=Number.POSITIVE_INFINITY] The initial window height
 * @returns {UseWindowSizeReturn} An object containing the current window width and height
 *
 * @example
 * const { width, height } = useWindowSize();
 */
export const useWindowSize = (params?: UseWindowSizeParams) => {
  const includeScrollbar = params?.includeScrollbar ?? true;
  const [size, setSize] = useState(() => {
    if (typeof window === 'undefined') {
      return {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      };
    }

    return {
      width: includeScrollbar ? window.innerWidth : window.document.documentElement.clientWidth,
      height: includeScrollbar ? window.innerHeight : window.document.documentElement.clientHeight
    };
  });

  useEffect(() => {
    const onResize = () => {
      const { innerWidth, innerHeight, document } = window;
      const { clientWidth, clientHeight } = document.documentElement;

      setSize({
        width: includeScrollbar ? innerWidth : clientWidth,
        height: includeScrollbar ? innerHeight : clientHeight
      });
    };

    window.addEventListener('resize', onResize);
    return () => window.removeEventListener('resize', onResize);
  }, [params?.includeScrollbar]);

  return size;
};
</file>

<file path="src/shared/lib/getElement.ts">
import type { RefObject } from 'react';

export type Target = (() => Element) | string | Document | Element | Window;
export type HookTarget =
  | RefObject<Element | null | undefined>
  | {
      value: Target;
      type: symbol;
    };

export const targetSymbol = Symbol('target');
export const target = (target: Target) => ({
  value: target,
  type: targetSymbol
});

export const getElement = (target: HookTarget) => {
  if ('current' in target) {
    return target.current;
  }

  if (typeof target.value === 'function') {
    return target.value();
  }

  if (typeof target.value === 'string') {
    return document.querySelector(target.value);
  }

  if (target.value instanceof Document) {
    return target.value;
  }

  if (target.value instanceof Window) {
    return target.value;
  }

  if (target.value instanceof Element) {
    return target.value;
  }

  return target.value;
};
</file>

<file path="src/shared/lib/group-by-date.ts">
import { IMemeDTO } from "@/entities/meme"

export interface GroupedMemes {
	label: string
	memes: IMemeDTO[]
}

/**
 * Группирует мемы по дате создания
 * @param memes - массив мемов
 * @returns массив групп с метками (Сегодня, Вчера, и т.д.)
 */
export function groupMemesByDate(memes: IMemeDTO[]): GroupedMemes[] {
	const now = new Date()
	const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())
	const yesterday = new Date(today)
	yesterday.setDate(yesterday.getDate() - 1)
	const thisWeekStart = new Date(today)
	thisWeekStart.setDate(thisWeekStart.getDate() - 7)
	const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1)

	const groups = {
		today: [] as IMemeDTO[],
		yesterday: [] as IMemeDTO[],
		thisWeek: [] as IMemeDTO[],
		thisMonth: [] as IMemeDTO[],
		older: [] as IMemeDTO[],
	}

	memes.forEach((meme) => {
		const memeDate = new Date(meme.createdAt)
		const memeDateOnly = new Date(
			memeDate.getFullYear(),
			memeDate.getMonth(),
			memeDate.getDate(),
		)

		if (memeDateOnly.getTime() === today.getTime()) {
			groups.today.push(meme)
		} else if (memeDateOnly.getTime() === yesterday.getTime()) {
			groups.yesterday.push(meme)
		} else if (memeDate >= thisWeekStart) {
			groups.thisWeek.push(meme)
		} else if (memeDate >= thisMonthStart) {
			groups.thisMonth.push(meme)
		} else {
			groups.older.push(meme)
		}
	})

	const result: GroupedMemes[] = []

	if (groups.today.length > 0) {
		result.push({ label: "Сегодня", memes: groups.today })
	}
	if (groups.yesterday.length > 0) {
		result.push({ label: "Вчера", memes: groups.yesterday })
	}
	if (groups.thisWeek.length > 0) {
		result.push({ label: "На этой неделе", memes: groups.thisWeek })
	}
	if (groups.thisMonth.length > 0) {
		result.push({ label: "В этом месяце", memes: groups.thisMonth })
	}
	if (groups.older.length > 0) {
		result.push({ label: "Ранее", memes: groups.older })
	}

	return result
}
</file>

<file path="src/shared/lib/search-params.ts">
import { parseAsInteger, parseAsString } from "nuqs/server"
import { createSearchParamsCache } from "nuqs/server"

// Describe your search params, and reuse this in useQueryStates / createSerializer:
export const memesSearchParams = {
	search: parseAsString.withDefault(""),
	page: parseAsInteger.withDefault(1),
} as const

export const searchParamsCache = createSearchParamsCache(memesSearchParams)
</file>

<file path="src/shared/lib/utils/index.ts">
export * from './isTarget';
</file>

<file path="src/shared/lib/utils/isTarget.ts">
import type { RefObject } from 'react';

export const targetSymbol = Symbol('target');

export type Target = (() => Element) | string | Document | Element | Window;

export type HookTarget =
  | RefObject<Element | null | undefined>
  | {
      value: Target;
      type: symbol;
    };

const getElement = (target: HookTarget) => {
  if ('current' in target) {
    return target.current;
  }

  if (typeof target.value === 'function') {
    return target.value();
  }

  if (typeof target.value === 'string') {
    return document.querySelector(target.value);
  }

  if (target.value instanceof Document) {
    return target.value;
  }

  if (target.value instanceof Window) {
    return target.value;
  }

  if (target.value instanceof Element) {
    return target.value;
  }

  return target.value;
};

export const target = (target: Target) => ({
  value: target,
  type: targetSymbol
});

export const isTarget = (target: HookTarget) =>
  typeof target === 'object' &&
  ('current' in target || (target && (target as any).type === targetSymbol));

isTarget.wrap = target;
isTarget.getElement = getElement;
</file>

<file path="src/shared/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/shared/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/shared/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/shared/lib/utils"

const badgeVariants = cva(
	"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
	{
		variants: {
			variant: {
				default:
					"border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
				secondary:
					"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
				destructive:
					"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
				outline: "text-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
)

export interface BadgeProps
	extends React.HTMLAttributes<HTMLDivElement>,
		VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
	return (
		<div className={cn(badgeVariants({ variant }), className)} {...props} />
	)
}

export { Badge, badgeVariants }
</file>

<file path="src/shared/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/shared/lib/utils"

const buttonVariants = cva(
	"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
	{
		variants: {
			variant: {
				default:
					"bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
				outline:
					"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-9 px-4 py-2 has-[>svg]:px-3",
				sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
				lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
				icon: "size-9",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
)

function Button({
	className,
	variant,
	size,
	asChild = false,
	...props
}: React.ComponentProps<"button"> &
	VariantProps<typeof buttonVariants> & {
		asChild?: boolean
	}) {
	const Comp = asChild ? Slot : "button"

	return (
		<Comp
			data-slot="button"
			className={cn(buttonVariants({ variant, size, className }))}
			{...props}
		/>
	)
}

export { Button, buttonVariants }
</file>

<file path="src/shared/ui/card.tsx">
import * as React from "react"

import { cn } from "@/shared/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="src/shared/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/shared/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
</file>

<file path="src/shared/ui/field.tsx">
"use client"

import { useMemo } from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/shared/lib/utils"
import { Label } from "@/shared/ui/label"
import { Separator } from "@/shared/ui/separator"

function FieldSet({ className, ...props }: React.ComponentProps<"fieldset">) {
  return (
    <fieldset
      data-slot="field-set"
      className={cn(
        "flex flex-col gap-6",
        "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
        className
      )}
      {...props}
    />
  )
}

function FieldLegend({
  className,
  variant = "legend",
  ...props
}: React.ComponentProps<"legend"> & { variant?: "legend" | "label" }) {
  return (
    <legend
      data-slot="field-legend"
      data-variant={variant}
      className={cn(
        "mb-3 font-medium",
        "data-[variant=legend]:text-base",
        "data-[variant=label]:text-sm",
        className
      )}
      {...props}
    />
  )
}

function FieldGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="field-group"
      className={cn(
        "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
        className
      )}
      {...props}
    />
  )
}

const fieldVariants = cva(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px",
        ],
        responsive: [
          "flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px",
        ],
      },
    },
    defaultVariants: {
      orientation: "vertical",
    },
  }
)

function Field({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof fieldVariants>) {
  return (
    <div
      role="group"
      data-slot="field"
      data-orientation={orientation}
      className={cn(fieldVariants({ orientation }), className)}
      {...props}
    />
  )
}

function FieldContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="field-content"
      className={cn(
        "group/field-content flex flex-1 flex-col gap-1.5 leading-snug",
        className
      )}
      {...props}
    />
  )
}

function FieldLabel({
  className,
  ...props
}: React.ComponentProps<typeof Label>) {
  return (
    <Label
      data-slot="field-label"
      className={cn(
        "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
        "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4",
        "has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10",
        className
      )}
      {...props}
    />
  )
}

function FieldTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="field-label"
      className={cn(
        "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
        className
      )}
      {...props}
    />
  )
}

function FieldDescription({ className, ...props }: React.ComponentProps<"p">) {
  return (
    <p
      data-slot="field-description"
      className={cn(
        "text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance",
        "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
        "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4",
        className
      )}
      {...props}
    />
  )
}

function FieldSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  children?: React.ReactNode
}) {
  return (
    <div
      data-slot="field-separator"
      data-content={!!children}
      className={cn(
        "relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2",
        className
      )}
      {...props}
    >
      <Separator className="absolute inset-0 top-1/2" />
      {children && (
        <span
          className="bg-background text-muted-foreground relative mx-auto block w-fit px-2"
          data-slot="field-separator-content"
        >
          {children}
        </span>
      )}
    </div>
  )
}

function FieldError({
  className,
  children,
  errors,
  ...props
}: React.ComponentProps<"div"> & {
  errors?: Array<{ message?: string } | undefined>
}) {
  const content = useMemo(() => {
    if (children) {
      return children
    }

    if (!errors?.length) {
      return null
    }

    if (errors?.length == 1) {
      return errors[0]?.message
    }

    return (
      <ul className="ml-4 flex list-disc flex-col gap-1">
        {errors.map(
          (error, index) =>
            error?.message && <li key={index}>{error.message}</li>
        )}
      </ul>
    )
  }, [children, errors])

  if (!content) {
    return null
  }

  return (
    <div
      role="alert"
      data-slot="field-error"
      className={cn("text-destructive text-sm font-normal", className)}
      {...props}
    >
      {content}
    </div>
  )
}

export {
  Field,
  FieldLabel,
  FieldDescription,
  FieldError,
  FieldGroup,
  FieldLegend,
  FieldSeparator,
  FieldSet,
  FieldContent,
  FieldTitle,
}
</file>

<file path="src/shared/ui/input.tsx">
import * as React from "react"

import { cn } from "@/shared/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
	return (
		<input
			type={type}
			data-slot="input"
			className={cn(
				"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-12 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
				"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
				"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
				className,
			)}
			{...props}
		/>
	)
}

export { Input }
</file>

<file path="src/shared/ui/inputLabel.tsx">
import React, { useId } from "react"
import { Input } from "./input"
import { FieldLabel } from "./field"

interface InputLabelProps extends React.ComponentProps<typeof Input> {
	label: string
	ref?: React.Ref<HTMLInputElement>
}

export default function InputLabel({ label, ref, ...props }: InputLabelProps) {
	const id = useId()
	return (
		<>
			<Input id={id} {...props} ref={ref} />
			<FieldLabel
				htmlFor={id}
				className="text-muted-foreground absolute top-1 left-3 cursor-text text-xs transition-all peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:text-base peer-focus:top-1 peer-focus:translate-y-0 peer-focus:text-xs"
			>
				{label}
			</FieldLabel>
		</>
	)
}
</file>

<file path="src/shared/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/shared/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/shared/ui/logo.tsx">
import React from "react"

const Logo = ({ className }: { className?: string }) => {
	return (
		<div className={className || "size-8"}>
			<svg
				xmlns="http://www.w3.org/2000/svg"
				viewBox="0 0 184 162"
				width="100%"
				height="100%"
			>
				<path d="M127 151H150V162H127V151Z" fill="currentColor" />
				<path d="M139 127H150V151H139V127Z" fill="currentColor" />
				<path d="M173 58H184V93H173V58Z" fill="currentColor" />
				<path d="M162 35H173V58H162V35Z" fill="currentColor" />
				<path d="M150 23H162V35H150V23Z" fill="currentColor" />
				<path d="M150 116H161V127H150V116Z" fill="currentColor" />
				<path d="M104 128H115V139H104V128Z" fill="currentColor" />
				<path d="M116 139H127V150H116V139Z" fill="currentColor" />
				<path d="M92 93H104V105H92V93Z" fill="currentColor" />
				<path d="M104 81H115V93H104V81Z" fill="currentColor" />
				<path d="M57 81H69V93H57V81Z" fill="currentColor" />
				<path d="M24 58H35V70H24V58Z" fill="currentColor" />
				<path d="M24 58H35V70H24V58Z" fill="currentColor" />
				<path d="M11 34H23V46H11V34Z" fill="currentColor" />
				<path d="M11 34H23V46H11V34Z" fill="currentColor" />
				<path d="M23 23H35V34H23V23Z" fill="currentColor" />
				<path d="M23 23H35V34H23V23Z" fill="currentColor" />
				<path d="M46 35H58V47H46V35Z" fill="currentColor" />
				<path d="M46 35H58V47H46V35Z" fill="currentColor" />
				<path d="M104 58H126V70H104V58Z" fill="currentColor" />
				<path d="M126 47H149V58H126V47Z" fill="currentColor" />
				<path d="M138 58H149V70H138V58Z" fill="currentColor" />
				<path d="M58 47H69V58H58V47Z" fill="currentColor" />
				<path d="M58 47H69V58H58V47Z" fill="currentColor" />
				<path d="M69 23H81V35H69V23Z" fill="currentColor" />
				<path d="M104 23H116V35H104V23Z" fill="currentColor" />
				<path d="M92 35H104V58H92V35Z" fill="currentColor" />
				<path d="M58 0H126V12H58V0Z" fill="currentColor" />
				<path d="M35 12H69V23H35V12Z" fill="currentColor" />
				<path d="M116 12H150V23H116V12Z" fill="currentColor" />
				<path d="M0 46H11V93H0V46Z" fill="currentColor" />
				<path d="M35 70H45V93H35V70Z" fill="currentColor" />
				<path d="M11 93H46V104H11V93Z" fill="currentColor" />
				<path d="M46 93H57V116H46V93Z" fill="currentColor" />
				<path d="M104 105H127V116H104V105Z" fill="currentColor" />
				<path d="M57 116H104V128H57V116Z" fill="currentColor" />
				<path d="M161 105H173V116H161V105Z" fill="currentColor" />
				<path d="M127 93H173V105H127V93Z" fill="currentColor" />
				<path d="M127 93H173V105H127V93Z" fill="currentColor" />
				<path d="M69 70H104V81H69V70Z" fill="currentColor" />
			</svg>
		</div>
	)
}

export default Logo
</file>

<file path="src/shared/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/shared/lib/utils"

const ScrollArea = React.forwardRef<
	React.ElementRef<typeof ScrollAreaPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
	<ScrollAreaPrimitive.Root
		ref={ref}
		className={cn("relative overflow-hidden", className)}
		{...props}
	>
		<ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
			{children}
		</ScrollAreaPrimitive.Viewport>
		<ScrollBar />
		<ScrollAreaPrimitive.Corner />
	</ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
	React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
	React.ComponentPropsWithoutRef<
		typeof ScrollAreaPrimitive.ScrollAreaScrollbar
	>
>(({ className, orientation = "vertical", ...props }, ref) => (
	<ScrollAreaPrimitive.ScrollAreaScrollbar
		ref={ref}
		orientation={orientation}
		className={cn(
			"flex touch-none transition-colors select-none",
			orientation === "vertical" &&
				"h-full w-2.5 border-l border-l-transparent p-[1px]",
			orientation === "horizontal" &&
				"h-2.5 border-t border-t-transparent p-[1px]",
			className,
		)}
		{...props}
	>
		<ScrollAreaPrimitive.ScrollAreaThumb className="bg-border relative flex-1 rounded-full" />
	</ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="src/shared/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/shared/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"border-input ring-offset-background placeholder:text-muted-foreground focus:ring-ring flex h-12 w-full items-center justify-between rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-sm focus:ring-1 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("px-2 py-1.5 text-sm font-semibold", className)}
		{...props}
	/>
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"focus:bg-accent focus:text-accent-foreground relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>
		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("bg-muted -mx-1 my-1 h-px", className)}
		{...props}
	/>
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
}
</file>

<file path="src/shared/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/shared/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="src/shared/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/shared/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
	return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
	...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
	return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
	...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
	return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
	...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
	return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
	className,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
	return (
		<SheetPrimitive.Overlay
			data-slot="sheet-overlay"
			className={cn(
				"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
				className,
			)}
			{...props}
		/>
	)
}

function SheetContent({
	className,
	children,
	side = "right",
	...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
	side?: "top" | "right" | "bottom" | "left"
}) {
	return (
		<SheetPortal>
			<SheetOverlay />
			<SheetPrimitive.Content
				data-slot="sheet-content"
				className={cn(
					"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
					side === "right" &&
						"data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
					side === "left" &&
						"data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
					side === "top" &&
						"data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
					side === "bottom" &&
						"data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
					className,
				)}
				{...props}
			>
				{children}
				<SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
					<XIcon className="size-4" />
					<span className="sr-only">Close</span>
				</SheetPrimitive.Close>
			</SheetPrimitive.Content>
		</SheetPortal>
	)
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sheet-header"
			className={cn("flex flex-col gap-1.5 p-4", className)}
			{...props}
		/>
	)
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sheet-footer"
			className={cn("mt-auto flex flex-col gap-2 p-4", className)}
			{...props}
		/>
	)
}

function SheetTitle({
	className,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
	return (
		<SheetPrimitive.Title
			data-slot="sheet-title"
			className={cn("text-foreground font-semibold", className)}
			{...props}
		/>
	)
}

function SheetDescription({
	className,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
	return (
		<SheetPrimitive.Description
			data-slot="sheet-description"
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	)
}

export {
	Sheet,
	SheetTrigger,
	SheetClose,
	SheetContent,
	SheetHeader,
	SheetFooter,
	SheetTitle,
	SheetDescription,
}
</file>

<file path="src/shared/ui/skeleton.tsx">
import { cn } from "@/shared/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/shared/ui/sonner.tsx">
"use client"

import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from "lucide-react"
import { useTheme } from "next-themes"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      icons={{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
          "--border-radius": "var(--radius)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/shared/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/shared/lib/utils"

function TooltipProvider({
	delayDuration = 0,
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
	return (
		<TooltipPrimitive.Provider
			data-slot="tooltip-provider"
			delayDuration={delayDuration}
			{...props}
		/>
	)
}

function Tooltip({
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
	return (
		<TooltipProvider>
			<TooltipPrimitive.Root data-slot="tooltip" {...props} />
		</TooltipProvider>
	)
}

function TooltipTrigger({
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
	return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
	className,
	sideOffset = 0,
	children,
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
	return (
		<TooltipPrimitive.Portal>
			<TooltipPrimitive.Content
				data-slot="tooltip-content"
				sideOffset={sideOffset}
				className={cn(
					"bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
					className,
				)}
				{...props}
			>
				{children}
				<TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
			</TooltipPrimitive.Content>
		</TooltipPrimitive.Portal>
	)
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/widgets/app-sidebar/index.ts">
// Public API for AppSidebar widget (FSD pattern)
export { AppSidebar } from "./ui/AppSidebar"
</file>

<file path="src/widgets/app-sidebar/ui/ThemeToggle.tsx">
"use client"

import { MoonIcon, SunIcon } from "lucide-react"
import { useTheme } from "next-themes"
import { useEffect, useState } from "react"
import { cn } from "@/shared/lib/utils"
import { Button } from "@/shared/ui/button"

export default function ThemeToggle({ className }: { className?: string }) {
	const { theme, setTheme } = useTheme()
	const [mounted, setMounted] = useState(false)

	// Avoid hydration mismatch
	useEffect(() => {
		setMounted(true)
	}, [])

	if (!mounted) {
		return <SunIcon className="size-6 cursor-pointer" />
	}

	const isDark = theme === "dark"

	return (
		<Button
			variant={"ghost"}
			size="icon"
			onClick={() => setTheme(isDark ? "light" : "dark")}
			className={cn(
				"cursor-pointer rounded-full transition-transform hover:scale-110",
				className,
			)}
			title={isDark ? "Светлая тема" : "Тёмная тема"}
		>
			{isDark ? (
				<SunIcon className="size-6" />
			) : (
				<MoonIcon className="size-6" />
			)}
		</Button>
	)
}
</file>

<file path="src/widgets/auth-layout/index.ts">
export { default } from "./AuthLayout"
</file>

<file path="src/widgets/meme-gallery/index.ts">
export { MemeGallery } from "./ui/MemeGallery"
</file>

<file path="src/widgets/meme-gallery/ui/MemeGallery.tsx">
"use client"

import { useMyMemesInfinite } from "@/entities/meme"
import { MemeCard } from "@/entities/meme"
import { Card, CardContent, CardHeader, CardTitle } from "@/shared/ui/card"
import { ScrollArea } from "@/shared/ui/scroll-area"
import { Skeleton } from "@/shared/ui/skeleton"
import { groupMemesByDate } from "@/shared/lib/group-by-date"
import { useRef } from "react"
import useIntersectionObserver from "@/shared/hooks/use-intersection-observer"
import { cn } from "@/shared/lib/utils"

export function MemeGallery({
	isGalleryPage = false,
}: {
	isGalleryPage?: boolean
}) {
	const { data, isLoading, isFetchingNextPage, hasNextPage, fetchNextPage } =
		useMyMemesInfinite(20)

	const loadMoreRef = useRef<HTMLDivElement>(null)

	// Infinity scroll observer
	useIntersectionObserver(
		(entries) => {
			const entry = entries[0]
			if (entry?.isIntersecting && hasNextPage && !isFetchingNextPage) {
				fetchNextPage()
			}
		},
		loadMoreRef,
		{ threshold: 0.1 },
	)

	// Объединяем все мемы из всех страниц
	const allMemes = data?.pages.flatMap((page) => page.data) ?? []

	// Группируем по датам
	const groupedMemes = groupMemesByDate(allMemes)

	return (
		<Card className="h-full w-full">
			{!isGalleryPage && (
				<CardHeader>
					<CardTitle className="font-pixelify text-2xl">
						Мои мемы
					</CardTitle>
				</CardHeader>
			)}
			<CardContent className="h-full p-0">
				<ScrollArea className="h-full rounded-lg px-6">
					{isLoading ? (
						<div className="grid grid-cols-1 gap-4 md:grid-cols-2">
							{Array.from({ length: 6 }).map((_, i) => (
								<Skeleton
									key={i}
									className="aspect-square rounded-lg"
								/>
							))}
						</div>
					) : allMemes.length > 0 ? (
						<div className="space-y-8">
							{groupedMemes.map((group) => (
								<div key={group.label} className="space-y-4">
									<h3 className="font-pixelify text-muted-foreground text-lg font-semibold">
										{group.label}
									</h3>
									<div
										className={cn(
											"grid gap-4",
											isGalleryPage
												? "grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4"
												: "grid-cols-1 md:grid-cols-2",
										)}
									>
										{group.memes.map((meme) => (
											<MemeCard
												key={meme.id}
												meme={meme}
											/>
										))}
									</div>
								</div>
							))}

							{/* Infinity scroll trigger */}
							<div ref={loadMoreRef} className="h-4 w-full" />

							{/* Loading indicator */}
							{isFetchingNextPage && (
								<div className="grid grid-cols-1 gap-4 md:grid-cols-2">
									{Array.from({ length: 4 }).map((_, i) => (
										<Skeleton
											key={i}
											className="aspect-square rounded-lg"
										/>
									))}
								</div>
							)}
						</div>
					) : (
						<div className="flex h-64 items-center justify-center">
							<p className="text-muted-foreground font-montserrat">
								У вас пока нет созданных мемов
							</p>
						</div>
					)}
				</ScrollArea>
			</CardContent>
		</Card>
	)
}
</file>

<file path="src/widgets/memes-list/index.ts">
// Public API for memes-list widget (FSD pattern)
export { MemesList } from "./ui/MemesList"
</file>

<file path="src/widgets/memes-list/ui/cards-skeleton.tsx">
import React from "react"
import { Skeleton } from "../../../shared/ui/skeleton"
import { cn } from "@/shared/lib/utils"

const pickRandomTailwindHeight = () => {
	const heights = ["h-56", "h-64", "h-72", "h-96"]
	return heights[Math.floor(Math.random() * heights.length)]
}

const CardsSkeleton = ({ columns }: { columns?: number }) => {
	const skeletonData = Array.from({ length: 30 })
		.fill(0)
		.map((_, index) => (
			<Skeleton
				key={index}
				className={`${pickRandomTailwindHeight()} relative mb-2 w-full break-inside-avoid`}
			/>
		))

	return (
		<div
			// tailwind не поддерживает динамические классы, поэтому используем cn
			className={cn(`w-full gap-2`, {
				"columns-1": columns === 1,
				"columns-2": columns === 2,
				"columns-3": columns === 3,
				"columns-4": columns === 4,
				"columns-5": columns === 5,
				"columns-6": columns === 6,
			})}
		>
			{skeletonData}
		</div>
	)
}

export default CardsSkeleton
</file>

<file path=".env.example">
# URL реального бэкенда (для auth и users)
NEXT_PUBLIC_API_URL=http://213.165.42.243:8082/
</file>

<file path=".github/copilot-instructions.md">
---
description: Feature-Sliced Design (FSD) architecture rules for building scalable frontend applications with business-oriented structure and strict layer hierarchy
globs: src/**/*
---

# Feature-Sliced Design (FSD) Architecture Rules

## Core Principles

- Organize code by business features, not technical concerns
- All dependencies between modules must be explicit and unidirectional
- Each slice should be as independent as possible
- Each module exposes only necessary functionality through its public API (index file)
- Follow strict layer hierarchy with unidirectional imports

## Project Structure

- Use 6-layer architecture: app → pages → widgets → features → entities → shared
- Each layer can only import from layers below it
- No cross-imports between slices on the same layer
- Public API through index.ts files only
- Colocate tests with implementation

## Layer Import Rules (Critical)

- **app** → can import from: pages, widgets, features, entities, shared
- **pages** → can import from: widgets, features, entities, shared
- **widgets** → can import from: features, entities, shared
- **features** → can import from: entities, shared
- **entities** → can import from: shared
- **shared** → cannot import from any layer

## Layer Responsibilities

### app/

- Application initialization and bootstrapping only
- Global providers setup (Router, Store, Theme, i18n)
- Global styles and CSS reset
- Entry point configuration
- NO business logic

### pages/

- Route/page components
- Page-level data fetching
- Layout composition from widgets and features
- Page-specific business logic
- SEO and metadata management
- Handle complex multi-step flows within a page

### widgets/

- Complex composite UI blocks
- Combine multiple features and entities
- Widget-specific state management
- Reusable across different pages

### features/

- User interactions and actions
- Business operations and workflows
- Feature-specific state and logic

### entities/

- Business entities representation
- Entity data models and types
- Entity-specific UI components
- CRUD operations for entities

### shared/

- Reusable utilities without business logic
- UI kit and design system components
- API client configuration
- Constants and configurations
- Type definitions and interfaces

## Segment Structure

- Each slice contains: ui/, model/, lib/, api/, config/, index.ts
- ui/ → UI components and styles
- model/ → State management (stores, events, effects)
- lib/ → Helper functions specific to slice
- api/ → API requests and data fetching
- config/ → Slice configuration
- index.ts → Public API exports only

## Naming Conventions

- Use **kebab-case** for folders and files
- Use **PascalCase** for components
- Use **camelCase** for utilities
- Use **UPPER_SNAKE_CASE** for constants
- Always use absolute imports with aliases (@/shared, @/features, etc.)

## Public API Rules

- Export only what's needed from index.ts
- Never export internal implementations
- Keep internal helpers and utilities private
- Use barrel exports for cleaner imports

## Anti-Patterns to Avoid

- Never import across slices on same layer
- Never import from non-public API (bypass index.ts)
- Never place business logic in shared layer
- Never create circular dependencies
- Never handle complex orchestration outside of pages
- Never violate layer hierarchy

## State Management

- Each layer can have its own stores
- Stores should be colocated with their features
- Use consistent state management patterns
- Handle cross-slice communication through events

## Testing

- Colocate tests with implementation
- Use .test.ts(x) or .spec.ts(x) suffix
- Test public API, not internal implementation
- Mock dependencies from lower layers

## Path Aliases Configuration

- Set up tsconfig paths for clean imports
- Use @/app, @/pages, @/widgets, @/features, @/entities, @/shared
- Configure bundler to resolve aliases
- Set up ESLint import order rules

## Migration Strategy

- Start with shared layer extraction
- Identify and extract business entities
- Extract features (user actions)
- Compose widgets from features/entities
- Refactor pages to use widgets/features
- Setup app layer with providers

## Tools and Resources

- Use Steiger linter for FSD validation
- Install @feature-sliced/eslint-config
- Reference https://feature-sliced.design
- Check examples at https://github.com/feature-sliced/examples
</file>

<file path="app/auth/layout.tsx">
import AuthLayout from "@/widgets/auth-layout"
import { ReactNode } from "react"

export default function Layout({ children }: { children: ReactNode }) {
	return <AuthLayout>{children}</AuthLayout>
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next"
import { Montserrat_Alternates, Pixelify_Sans } from "next/font/google"
import "@/app/globals.css"
import { Providers } from "@/app/providers"

const montserrat = Montserrat_Alternates({
	variable: "--font-montserrat",
	subsets: ["latin", "cyrillic"],
	weight: ["400", "500", "600", "700"],
})

const pixelify = Pixelify_Sans({
	variable: "--font-pixelify-sans",
	subsets: ["latin", "cyrillic"],
	weight: ["400", "500", "600", "700"],
})

export const metadata: Metadata = {
	title: "AI Memes - Create and Share Funny Memes",
	description: "Create, share, and discover funny memes powered by AI",
}

export default async function RootLayout({
	children,
}: Readonly<{
	children: React.ReactNode
}>) {
	return (
		<html lang="ru">
			<head>
				<script
					dangerouslySetInnerHTML={{
						__html: `
                            (function() {
                                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                                if (mediaQuery.matches) {
                                    document.documentElement.classList.add('dark');
                                }
                            })();
                        `,
					}}
				/>
			</head>
			<body
				suppressHydrationWarning
				className={`${pixelify.variable} ${montserrat.variable} antialiased`}
			>
				<Providers>{children}</Providers>
			</body>
		</html>
	)
}
</file>

<file path="components.json">
{
	"$schema": "https://ui.shadcn.com/schema.json",
	"style": "new-york",
	"rsc": true,
	"tsx": true,
	"tailwind": {
		"config": "",
		"css": "src/app/globals.css",
		"baseColor": "neutral",
		"cssVariables": true,
		"prefix": ""
	},
	"iconLibrary": "lucide",
	"aliases": {
		"components": "@/shared/ui",
		"utils": "@/shared/lib/utils",
		"ui": "@/shared/ui",
		"lib": "@/shared/lib",
		"hooks": "@/shared/hooks"
	},
	"registries": {}
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";
import pluginQuery from "@tanstack/eslint-plugin-query";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

// add tanstack query lint
const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  ...pluginQuery.configs["flat/recommended"],
  ...tailwind.configs["flat/recommended"],
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;
</file>

<file path="middleware.ts">
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

const privateRoutes = ["/create", "/gallery"]

const authRoutes = ["/auth/login", "/auth/register"]

export function middleware(request: NextRequest) {
	const { pathname } = request.nextUrl

	const token =
		request.cookies.get("access_token")?.value ||
		request.headers.get("Authorization")?.split("Bearer ")[1]

	if (privateRoutes.some((route) => pathname.startsWith(route)) && !token) {
		const url = request.nextUrl.clone()
		url.pathname = "/auth/login"
		url.searchParams.set("redirect", pathname)
		return NextResponse.redirect(url)
	}

	if (authRoutes.some((route) => pathname.startsWith(route)) && token) {
		const url = request.nextUrl.clone()
		url.pathname = "/create"
		return NextResponse.redirect(url)
	}

	return NextResponse.next()
}

export const config = {
	matcher: [
		/*
		 * Match all request paths except for the ones starting with:
		 * - api (API routes)
		 * - _next/static (static files)
		 * - _next/image (image optimization files)
		 * - favicon.ico (favicon file)
		 */
		"/((?!api|_next/static|_next/image|favicon.ico).*)",
	],
}
</file>

<file path="reactuse.json">
{
	"ts": true,
	"aliases": {
		"hooks": "@/shared/hooks",
		"utils": "@/shared/lib/utils"
	}
}
</file>

<file path="src/entities/meme/index.ts">
export {
	useMyMemesInfinite,
	useMemeStyles,
	useMemeStatus,
	memeKeys,
} from "./model/queries"
export type {
	MemeStatus,
	CreateMemeRequest,
	IMemeListDTO,
	IMemeDTO,
} from "./model/types"
export { MemeCard } from "./ui"
export { MemeDTO, MemesListDTO } from "./model/dto"
</file>

<file path="src/entities/user/api/useGetUser.ts">
import { getUserProfile } from "@/shared/api"
import { useQuery } from "@tanstack/react-query"

export const useGetUser = () => {
	return useQuery({
		queryKey: ["user"],
		retry: 1,
		queryFn: async () => {
			const { data } = await getUserProfile()
			return data
		},
	})
}
</file>

<file path="src/entities/user/api/useLogoutUser.ts">
import { logoutUser } from "@/shared/api"
import { useMutation, useQueryClient } from "@tanstack/react-query"

export const useLogoutUser = () => {
	const queryClient = useQueryClient()

	return useMutation({
		mutationKey: ["logout"],
		mutationFn: async () => {
			const { data } = await logoutUser()
			return data
		},
		onSuccess: () => {
			queryClient.removeQueries({ queryKey: ["user"] })
		},
	})
}
</file>

<file path="src/features/search-memes/ui/SearchInput.tsx">
"use client"

import { useQueryState, parseAsString } from "nuqs"
import { Input } from "@/shared/ui/input"
import { useEffect, useState } from "react"

export function SearchInput() {
	const [search, setSearch] = useQueryState(
		"search",
		parseAsString.withDefault("").withOptions({
			shallow: false,
		}),
	)
	const [viewSearch, setViewSearch] = useState(search)

	useEffect(() => {
		const timeout = setTimeout(() => {
			setSearch(viewSearch)
		}, 1000)

		return () => clearTimeout(timeout)
	}, [viewSearch])

	return (
		<Input
			disabled
			className="flex-1"
			placeholder="Поиск мемов..."
			value={viewSearch}
			onChange={(e) => {
				setViewSearch(e.target.value)
			}}
			onKeyDown={(e) => {
				if (e.key === "Enter") {
					setSearch(e.currentTarget.value || null, {
						throttleMs: 0,
					})
				}
			}}
		/>
	)
}
</file>

<file path="src/pages/home/ui/HomePage.tsx">
import { Suspense } from "react"
import type { Metadata } from "next"
import { typedApiClient } from "@/shared/api/typed-client"
import { SidebarTrigger } from "@/shared/ui/sidebar"
import { Button } from "@/shared/ui/button"
import { PlusCircle } from "lucide-react"
import { searchParamsCache } from "@/shared/lib/search-params"
import { MemesList } from "@/widgets/memes-list"
import CardsSkeleton from "@/widgets/memes-list/ui/cards-skeleton"
import { SearchInput } from "@/features/search-memes"
import type { SearchParams } from "nuqs/server"
import Link from "next/link"
import { MemesListDTO } from "@/entities/meme/model/dto"

export const metadata: Metadata = {
	title: "Мемы - AI Memes",
	description: "Просматривайте и создавайте смешные мемы с помощью ИИ",
}

async function GetAllMemes() {
	const { page, search } = searchParamsCache.all()

	const { data: memes, error } = await typedApiClient.GET("/memes/public", {
		params: {
			query: {
				limit: 30,
				offset: ((page || 1) - 1) * 30,
			},
		},
	})

	if (error || !memes) {
		console.error("Error fetching memes:", error)
		return <div className="p-4">Ошибка загрузки мемов</div>
	}

	const transformedData = MemesListDTO.fromApi(memes)

	return <MemesList initialData={transformedData} search={search || ""} />
}

export default async function HomePage({
	searchParams,
}: {
	searchParams: Promise<SearchParams>
}) {
	const parsed = await searchParamsCache.parse(searchParams)
	const { page, search } = parsed

	const suspenseKey = `memes-${page}-${search}`

	return (
		<div className="flex min-h-screen max-w-full flex-col">
			<header className="bg-background sticky top-0 z-10 flex items-center gap-4 border-b p-2">
				<SidebarTrigger className="size-12" />
				<h2 className="font-pixelify-sans text-2xl font-light">
					Главная
				</h2>
				<SearchInput />
				<Button className="" size={"icon"} asChild>
					<Link href="/create">
						<PlusCircle />
					</Link>
				</Button>
			</header>
			<main className="bg-background relative flex-1 overflow-hidden px-4">
				<Suspense
					key={suspenseKey}
					fallback={
						<div className="mt-4">
							<CardsSkeleton columns={4} />
						</div>
					}
				>
					<GetAllMemes />
				</Suspense>
			</main>
		</div>
	)
}
</file>

<file path="src/pages/register/api/useRegister.ts">
import { RegisterRequest, registerUser } from "@/shared/api"
import { useMutation, useQueryClient } from "@tanstack/react-query"

export const useRegister = () => {
	const queryClient = useQueryClient()

	return useMutation({
		mutationKey: ["register"],
		mutationFn: async (body: RegisterRequest) => {
			const { data, error } = await registerUser(body)

			if (error) {
				throw new Error(
					error.error || "Login failed. Please try again.",
				)
			}

			return data
		},
		onSuccess: (authResponse) => {
			// Сохраняем данные пользователя в кэш
			if (authResponse?.user) {
				queryClient.setQueryData(["user"], authResponse.user)
			}
		},
	})
}
</file>

<file path="src/pages/register/model/register.model.ts">
import z from "zod"

export const registerSchema = z
	.object({
		username: z
			.string()
			.min(2, { message: "Username must be at least 2 characters" }),
		email: z.email({ message: "Enter a valid email address" }),
		password: z
			.string()
			.min(6, { message: "Password must be at least 6 characters" }),
		confirmPassword: z.string(),
	})
	.refine((data) => data.password === data.confirmPassword, {
		message: "Passwords don't match",
		path: ["confirmPassword"],
	})

export type RegisterForm = z.infer<typeof registerSchema>
</file>

<file path="src/shared/api/config.ts">
/**
 * Конфигурация API клиента
 */

import { env } from "../config/env"

// Базовый URL API
export const BACKEND_URL = env.NEXT_PUBLIC_API_URL
</file>

<file path="src/shared/api/typed-client.ts">
/**
 * Типизированный API клиент на основе openapi-fetch
 * Использует автоматически сгенерированные типы из api-schema.d.ts
 *
 * Поддерживает гибридный режим:
 * - Auth/Users эндпоинты → реальный бэкенд
 * - Остальные эндпоинты → MSW моки
 *
 * @see https://openapi-ts.dev/openapi-fetch/
 */

import createClient, { type Middleware } from "openapi-fetch"
import type { paths } from "./api-schema"
import { redirect } from "next/navigation"
import { env } from "../config/env"

// Базовый URL API (для реального бэкенда)
const API_BASE_URL = env.NEXT_PUBLIC_API_URL

let isRefreshing = false
let failedQueue: Array<{
	resolve: (value?: unknown) => void
	reject: (reason?: unknown) => void
}> = []

const processQueue = (error: Error | null) => {
	failedQueue.forEach((prom) => {
		if (error) {
			prom.reject(error)
		} else {
			prom.resolve()
		}
	})
	failedQueue = []
}

const authMiddleware: Middleware = {
	async onRequest({ request }) {
		const modifiedRequest = new Request(request, {
			credentials: "include",
		})
		return modifiedRequest
	},
	async onResponse({ response, request }) {
		if (response.ok) {
			return response
		}

		if (response.status === 401) {
			const originalRequest = request.clone()

			if (isRefreshing) {
				return new Promise((resolve, reject) => {
					failedQueue.push({ resolve, reject })
				})
					.then(() => {
						return fetch(originalRequest)
					})
					.catch((err) => {
						return Promise.reject(err)
					})
			}

			isRefreshing = true

			try {
				const refreshResponse = await fetch(
					`${API_BASE_URL}/auth/refresh`,
					{
						method: "POST",
						credentials: "include",
						headers: {
							"Content-Type": "application/json",
						},
					},
				)

				if (refreshResponse.ok) {
					processQueue(null)
					isRefreshing = false

					return fetch(originalRequest)
				} else {
					processQueue(new Error("Failed to refresh token"))
					isRefreshing = false

					return response
				}
			} catch (error) {
				processQueue(error as Error)
				isRefreshing = false

				return response
			}
		}

		return response
	},
}

// Создаём типизированный клиент
export const typedApiClient = createClient<paths>({
	baseUrl: API_BASE_URL,
	credentials: "include",
	headers: {
		"Content-Type": "application/json",
	},
})

// Добавляем middleware
typedApiClient.use(authMiddleware)

/**
 * Примеры использования:
 *
 * // Регистрация пользователя
 * const { data, error } = await typedApiClient.POST("/auth/register", {
 *   body: {
 *     username: "johndoe",
 *     email: "john@example.com",
 *     password: "password123"
 *   }
 * })
 *
 * // Вход в систему
 * const { data, error } = await typedApiClient.POST("/auth/login", {
 *   body: {
 *     username: "johndoe",
 *     password: "password123"
 *   }
 * })
 *
 * // Получение профиля
 * const { data, error } = await typedApiClient.GET("/users/profile")
 *
 * // Обновление профиля
 * const { data, error } = await typedApiClient.PUT("/users/profile/update", {
 *   body: {
 *     username: "johndoe_new",
 *     email: "john.new@example.com"
 *   }
 * })
 *
 * // Получение списка пользователей с пагинацией
 * const { data, error } = await typedApiClient.GET("/users/list", {
 *   params: {
 *     query: {
 *       limit: 10,
 *       offset: 0
 *     }
 *   }
 * })
 */

export default typedApiClient
</file>

<file path="src/shared/api/user/auth.ts">
/**
 * API функции для работы с аутентификацией
 * Используют типизированный клиент с автоматической генерацией типов
 */

import { typedApiClient } from "../typed-client"
import type { components } from "../api-schema"

export type AuthResponse = components["schemas"]["services.AuthResponse"]
export type LoginRequest = components["schemas"]["services.LoginRequest"]
export type RegisterRequest = components["schemas"]["services.RegisterRequest"]

/**
 * Регистрация нового пользователя
 *
 * @example
 * const result = await registerUser({
 *   username: "johndoe",
 *   email: "john@example.com",
 *   password: "password123"
 * })
 *
 * if (result.data) {
 *   console.log("User registered:", result.data.user)
 *   console.log("Access token:", result.data.access_token)
 * } else if (result.error) {
 *   console.error("Registration failed:", result.error)
 * }
 */
export async function registerUser(data: RegisterRequest) {
	return await typedApiClient.POST("/auth/register", {
		body: data,
	})
}

/**
 * Вход в систему
 *
 * @example
 * const result = await loginUser({
 *   username: "johndoe",
 *   password: "password123"
 * })
 *
 * if (result.data) {
 *   console.log("Login successful:", result.data.user)
 * }
 */
export async function loginUser(data: LoginRequest) {
	return await typedApiClient.POST("/auth/login", {
		body: data,
	})
}

/**
 * Выход из системы
 *
 * @example
 * const result = await logoutUser({ refresh_token: "..." })
 *
 * if (result.data) {
 *   console.log("Logout successful:", result.data.message)
 * }
 */
export async function logoutUser() {
	return await typedApiClient.POST("/auth/logout")
}

/**
 * Выход из всех устройств
 *
 * @example
 * const result = await logoutAllDevices()
 *
 * if (result.data) {
 *   console.log("Logged out from all devices:", result.data.message)
 * }
 */
export async function logoutAllDevices() {
	return await typedApiClient.POST("/auth/logout-all")
}

/**
 * Обновление access токена
 *
 * @example
 * const result = await refreshAccessToken({ refresh_token: "..." })
 *
 * if (result.data) {
 *   console.log("New access token:", result.data.access_token)
 * }
 */
export async function refreshAccessToken() {
	return await typedApiClient.POST("/auth/refresh")
}
</file>

<file path="src/shared/config/env.ts">
import { z } from "zod"

export const envSchema = z.object({
	NEXT_PUBLIC_API_URL: z.string().default("http://localhost:3000/api/v1"),
})

export type Env = z.infer<typeof envSchema>

function validateEnv(): Env {
	const config = {
		NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
	}

	try {
		return envSchema.parse(config)
	} catch (error) {
		if (error instanceof z.ZodError) {
			const errorMessages = error.issues
				.map((err) => `  - ${err.path.join(".")}: ${err.message}`)
				.join("\n")

			console.error(
				`❌ Ошибка валидации переменных окружения:\n${errorMessages}`,
			)
			console.error("Доступные переменные:", config)

			throw new Error(
				`❌ Ошибка валидации переменных окружения:\n${errorMessages}`,
			)
		}
		throw error
	}
}

export const env = validateEnv()
</file>

<file path="src/shared/config/routes.ts">
/**
 * Константы для API роутов приложения
 */

// Базовый URL API
export const API_BASE_URL =
	process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000/api"

/**
 * API эндпоинты
 */
export const API_ROUTES = {
	// Мемы
	MEMES: {
		LIST: `${API_BASE_URL}/memes`,
		DETAIL: (id: string) => `${API_BASE_URL}/memes/${id}`,
		CREATE: `${API_BASE_URL}/memes`,
		UPDATE: (id: string) => `${API_BASE_URL}/memes/${id}`,
		DELETE: (id: string) => `${API_BASE_URL}/memes/${id}`,
		GENERATE: `${API_BASE_URL}/memes/generate`,
		TASK_STATUS: (id: string) => `${API_BASE_URL}/memes/task/${id}`,
		TASK_RESULT: (id: string) => `${API_BASE_URL}/memes/task/${id}/result`,
		STYLES: `${API_BASE_URL}/memes/styles`,
	},

	// Пользователи
	USERS: {
		ME: `${API_BASE_URL}/users/me`,
		PROFILE: (id: string) => `${API_BASE_URL}/users/${id}`,
		UPDATE: `${API_BASE_URL}/users/me`,
	},

	// Аутентификация
	AUTH: {
		LOGIN: `${API_BASE_URL}/auth/login`,
		LOGOUT: `${API_BASE_URL}/auth/logout`,
		REGISTER: `${API_BASE_URL}/auth/register`,
		REFRESH: `${API_BASE_URL}/auth/refresh`,
	},
} as const

/**
 * Роуты страниц приложения
 */
export const APP_ROUTES = {
	HOME: "/",
	MEMES: "/memes",
	MEME_DETAIL: (id: string) => `/memes/${id}`,
	CREATE_MEME: "/memes/create",
	PROFILE: "/profile",
	LOGIN: "/login",
	REGISTER: "/register",
} as const
</file>

<file path="src/shared/hooks/index.ts">
export * from "./use-mobile"
export * from "./use-intersection-observer"
export * from "./useElementSize/useElementSize"
export * from "./useIsomorphicLayoutEffect/useIsomorphicLayoutEffect"
export * from "./useRefState/useRefState"
export * from "./useWindowSize/useWindowSize"
</file>

<file path="src/shared/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
import { toast } from "sonner"

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs))
}

export const customToast = (
	message: string,
	type: "success" | "error" | "info",
) => {
	const colors = {
		success: {
			background: "#34A200",
			text: "white",
		},
		error: {
			background: "#FF3333",
			text: "white",
		},
		info: {
			background: "#0095BE",
			text: "black",
		},
	}

	return toast(message, {
		duration: 4000,
		style: {
			background: colors[type].background,
			color: colors[type].text,
		},
	})
}
</file>

<file path="src/shared/ui/sidebar.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, VariantProps } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/shared/hooks"
import { cn } from "@/shared/lib/utils"
import { Button } from "@/shared/ui/button"
import { Input } from "@/shared/ui/input"
import { Separator } from "@/shared/ui/separator"
import {
	Sheet,
	SheetContent,
	SheetDescription,
	SheetHeader,
	SheetTitle,
} from "@/shared/ui/sheet"
import { Skeleton } from "@/shared/ui/skeleton"
import {
	Tooltip,
	TooltipContent,
	TooltipProvider,
	TooltipTrigger,
} from "@/shared/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
	state: "expanded" | "collapsed"
	open: boolean
	setOpen: (open: boolean) => void
	openMobile: boolean
	setOpenMobile: (open: boolean) => void
	isMobile: boolean
	toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
	const context = React.useContext(SidebarContext)
	if (!context) {
		throw new Error("useSidebar must be used within a SidebarProvider.")
	}

	return context
}

function SidebarProvider({
	defaultOpen = true,
	open: openProp,
	onOpenChange: setOpenProp,
	className,
	style,
	children,
	...props
}: React.ComponentProps<"div"> & {
	defaultOpen?: boolean
	open?: boolean
	onOpenChange?: (open: boolean) => void
}) {
	const isMobile = useIsMobile()
	const [openMobile, setOpenMobile] = React.useState(false)

	// This is the internal state of the sidebar.
	// We use openProp and setOpenProp for control from outside the component.
	const [_open, _setOpen] = React.useState(defaultOpen)
	const open = openProp ?? _open
	const setOpen = React.useCallback(
		(value: boolean | ((value: boolean) => boolean)) => {
			const openState = typeof value === "function" ? value(open) : value
			if (setOpenProp) {
				setOpenProp(openState)
			} else {
				_setOpen(openState)
			}

			// This sets the cookie to keep the sidebar state.
			document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
		},
		[setOpenProp, open],
	)

	// Helper to toggle the sidebar.
	const toggleSidebar = React.useCallback(() => {
		return isMobile
			? setOpenMobile((open) => !open)
			: setOpen((open) => !open)
	}, [isMobile, setOpen, setOpenMobile])

	// Adds a keyboard shortcut to toggle the sidebar.
	React.useEffect(() => {
		const handleKeyDown = (event: KeyboardEvent) => {
			if (
				event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
				(event.metaKey || event.ctrlKey)
			) {
				event.preventDefault()
				toggleSidebar()
			}
		}

		window.addEventListener("keydown", handleKeyDown)
		return () => window.removeEventListener("keydown", handleKeyDown)
	}, [toggleSidebar])

	// We add a state so that we can do data-state="expanded" or "collapsed".
	// This makes it easier to style the sidebar with Tailwind classes.
	const state = open ? "expanded" : "collapsed"

	const contextValue = React.useMemo<SidebarContextProps>(
		() => ({
			state,
			open,
			setOpen,
			isMobile,
			openMobile,
			setOpenMobile,
			toggleSidebar,
		}),
		[
			state,
			open,
			setOpen,
			isMobile,
			openMobile,
			setOpenMobile,
			toggleSidebar,
		],
	)

	return (
		<SidebarContext.Provider value={contextValue}>
			<TooltipProvider delayDuration={0}>
				<div
					data-slot="sidebar-wrapper"
					style={
						{
							"--sidebar-width": SIDEBAR_WIDTH,
							"--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
							...style,
						} as React.CSSProperties
					}
					className={cn(
						"group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
						className,
					)}
					{...props}
				>
					{children}
				</div>
			</TooltipProvider>
		</SidebarContext.Provider>
	)
}

function Sidebar({
	side = "left",
	variant = "sidebar",
	collapsible = "offcanvas",
	className,
	children,
	...props
}: React.ComponentProps<"div"> & {
	side?: "left" | "right"
	variant?: "sidebar" | "floating" | "inset"
	collapsible?: "offcanvas" | "icon" | "none"
}) {
	const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

	if (collapsible === "none") {
		return (
			<div
				data-slot="sidebar"
				className={cn(
					"bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
					className,
				)}
				{...props}
			>
				{children}
			</div>
		)
	}

	if (isMobile) {
		return (
			<Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
				<SheetContent
					data-sidebar="sidebar"
					data-slot="sidebar"
					data-mobile="true"
					className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
					style={
						{
							"--sidebar-width": SIDEBAR_WIDTH_MOBILE,
						} as React.CSSProperties
					}
					side={side}
				>
					<SheetHeader className="sr-only">
						<SheetTitle>Sidebar</SheetTitle>
						<SheetDescription>
							Displays the mobile sidebar.
						</SheetDescription>
					</SheetHeader>
					<div className="flex h-full w-full flex-col">
						{children}
					</div>
				</SheetContent>
			</Sheet>
		)
	}

	return (
		<div
			className="group peer text-sidebar-foreground hidden md:block"
			data-state={state}
			data-collapsible={state === "collapsed" ? collapsible : ""}
			data-variant={variant}
			data-side={side}
			data-slot="sidebar"
		>
			{/* This is what handles the sidebar gap on desktop */}
			<div
				data-slot="sidebar-gap"
				className={cn(
					"relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
					"group-data-[collapsible=offcanvas]:w-0",
					"group-data-[side=right]:rotate-180",
					variant === "floating" || variant === "inset"
						? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
						: "group-data-[collapsible=icon]:w-(--sidebar-width-icon)",
				)}
			/>
			<div
				data-slot="sidebar-container"
				className={cn(
					"fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
					side === "left"
						? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
						: "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
					// Adjust the padding for floating and inset variants.
					variant === "floating" || variant === "inset"
						? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
						: "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
					className,
				)}
				{...props}
			>
				<div
					data-sidebar="sidebar"
					data-slot="sidebar-inner"
					className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
				>
					{children}
				</div>
			</div>
		</div>
	)
}

function SidebarTrigger({
	className,
	onClick,
	...props
}: React.ComponentProps<typeof Button>) {
	const { toggleSidebar } = useSidebar()

	return (
		<Button
			data-sidebar="trigger"
			data-slot="sidebar-trigger"
			variant="ghost"
			size="icon"
			className={cn("size-7 cursor-pointer", className)}
			onClick={(event) => {
				onClick?.(event)
				toggleSidebar()
			}}
			{...props}
		>
			<PanelLeftIcon className="text-primary size-6" />
			<span className="sr-only">Toggle Sidebar</span>
		</Button>
	)
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
	const { toggleSidebar } = useSidebar()

	return (
		<button
			data-sidebar="rail"
			data-slot="sidebar-rail"
			aria-label="Toggle Sidebar"
			tabIndex={-1}
			onClick={toggleSidebar}
			title="Toggle Sidebar"
			className={cn(
				"hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
				"in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
				"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
				"hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
				"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
				"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
	return (
		<main
			data-slot="sidebar-inset"
			className={cn(
				"bg-background relative flex w-full flex-1 flex-col",
				"md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarInput({
	className,
	...props
}: React.ComponentProps<typeof Input>) {
	return (
		<Input
			data-slot="sidebar-input"
			data-sidebar="input"
			className={cn("bg-background h-8 w-full shadow-none", className)}
			{...props}
		/>
	)
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sidebar-header"
			data-sidebar="header"
			className={cn("flex flex-col gap-2 p-2", className)}
			{...props}
		/>
	)
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sidebar-footer"
			data-sidebar="footer"
			className={cn("flex flex-col gap-2 p-2", className)}
			{...props}
		/>
	)
}

function SidebarSeparator({
	className,
	...props
}: React.ComponentProps<typeof Separator>) {
	return (
		<Separator
			data-slot="sidebar-separator"
			data-sidebar="separator"
			className={cn("bg-sidebar-border mx-2 w-auto", className)}
			{...props}
		/>
	)
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sidebar-content"
			data-sidebar="content"
			className={cn(
				"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sidebar-group"
			data-sidebar="group"
			className={cn(
				"relative flex w-full min-w-0 flex-col p-2",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarGroupLabel({
	className,
	asChild = false,
	...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
	const Comp = asChild ? Slot : "div"

	return (
		<Comp
			data-slot="sidebar-group-label"
			data-sidebar="group-label"
			className={cn(
				"text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
				"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarGroupAction({
	className,
	asChild = false,
	...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
	const Comp = asChild ? Slot : "button"

	return (
		<Comp
			data-slot="sidebar-group-action"
			data-sidebar="group-action"
			className={cn(
				"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
				// Increases the hit area of the button on mobile.
				"after:absolute after:-inset-2 md:after:hidden",
				"group-data-[collapsible=icon]:hidden",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarGroupContent({
	className,
	...props
}: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sidebar-group-content"
			data-sidebar="group-content"
			className={cn("w-full text-sm", className)}
			{...props}
		/>
	)
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
	return (
		<ul
			data-slot="sidebar-menu"
			data-sidebar="menu"
			className={cn("flex w-full min-w-0 flex-col gap-1", className)}
			{...props}
		/>
	)
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
	return (
		<li
			data-slot="sidebar-menu-item"
			data-sidebar="menu-item"
			className={cn("group/menu-item relative", className)}
			{...props}
		/>
	)
}

const sidebarMenuButtonVariants = cva(
	"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
	{
		variants: {
			variant: {
				default:
					"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
				outline:
					"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
			},
			size: {
				default: "h-8 text-sm",
				sm: "h-7 text-xs",
				lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
)

function SidebarMenuButton({
	asChild = false,
	isActive = false,
	variant = "default",
	size = "default",
	tooltip,
	className,
	...props
}: React.ComponentProps<"button"> & {
	asChild?: boolean
	isActive?: boolean
	tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
	const Comp = asChild ? Slot : "button"
	const { isMobile, state } = useSidebar()

	const button = (
		<Comp
			data-slot="sidebar-menu-button"
			data-sidebar="menu-button"
			data-size={size}
			data-active={isActive}
			className={cn(
				sidebarMenuButtonVariants({ variant, size }),
				className,
			)}
			{...props}
		/>
	)

	if (!tooltip) {
		return button
	}

	if (typeof tooltip === "string") {
		tooltip = {
			children: tooltip,
		}
	}

	return (
		<Tooltip>
			<TooltipTrigger asChild>{button}</TooltipTrigger>
			<TooltipContent
				side="right"
				align="center"
				hidden={state !== "collapsed" || isMobile}
				{...tooltip}
			/>
		</Tooltip>
	)
}

function SidebarMenuAction({
	className,
	asChild = false,
	showOnHover = false,
	...props
}: React.ComponentProps<"button"> & {
	asChild?: boolean
	showOnHover?: boolean
}) {
	const Comp = asChild ? Slot : "button"

	return (
		<Comp
			data-slot="sidebar-menu-action"
			data-sidebar="menu-action"
			className={cn(
				"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
				// Increases the hit area of the button on mobile.
				"after:absolute after:-inset-2 md:after:hidden",
				"peer-data-[size=sm]/menu-button:top-1",
				"peer-data-[size=default]/menu-button:top-1.5",
				"peer-data-[size=lg]/menu-button:top-2.5",
				"group-data-[collapsible=icon]:hidden",
				showOnHover &&
					"peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarMenuBadge({
	className,
	...props
}: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sidebar-menu-badge"
			data-sidebar="menu-badge"
			className={cn(
				"text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
				"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
				"peer-data-[size=sm]/menu-button:top-1",
				"peer-data-[size=default]/menu-button:top-1.5",
				"peer-data-[size=lg]/menu-button:top-2.5",
				"group-data-[collapsible=icon]:hidden",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarMenuSkeleton({
	className,
	showIcon = false,
	...props
}: React.ComponentProps<"div"> & {
	showIcon?: boolean
}) {
	// Random width between 50 to 90%.
	const width = React.useMemo(() => {
		return `${Math.floor(Math.random() * 40) + 50}%`
	}, [])

	return (
		<div
			data-slot="sidebar-menu-skeleton"
			data-sidebar="menu-skeleton"
			className={cn(
				"flex h-8 items-center gap-2 rounded-md px-2",
				className,
			)}
			{...props}
		>
			{showIcon && (
				<Skeleton
					className="size-4 rounded-md"
					data-sidebar="menu-skeleton-icon"
				/>
			)}
			<Skeleton
				className="h-4 max-w-(--skeleton-width) flex-1"
				data-sidebar="menu-skeleton-text"
				style={
					{
						"--skeleton-width": width,
					} as React.CSSProperties
				}
			/>
		</div>
	)
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
	return (
		<ul
			data-slot="sidebar-menu-sub"
			data-sidebar="menu-sub"
			className={cn(
				"border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
				"group-data-[collapsible=icon]:hidden",
				className,
			)}
			{...props}
		/>
	)
}

function SidebarMenuSubItem({
	className,
	...props
}: React.ComponentProps<"li">) {
	return (
		<li
			data-slot="sidebar-menu-sub-item"
			data-sidebar="menu-sub-item"
			className={cn("group/menu-sub-item relative", className)}
			{...props}
		/>
	)
}

function SidebarMenuSubButton({
	asChild = false,
	size = "md",
	isActive = false,
	className,
	...props
}: React.ComponentProps<"a"> & {
	asChild?: boolean
	size?: "sm" | "md"
	isActive?: boolean
}) {
	const Comp = asChild ? Slot : "a"

	return (
		<Comp
			data-slot="sidebar-menu-sub-button"
			data-sidebar="menu-sub-button"
			data-size={size}
			data-active={isActive}
			className={cn(
				"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
				"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
				size === "sm" && "text-xs",
				size === "md" && "text-sm",
				"group-data-[collapsible=icon]:hidden",
				className,
			)}
			{...props}
		/>
	)
}

export {
	Sidebar,
	SidebarContent,
	SidebarFooter,
	SidebarGroup,
	SidebarGroupAction,
	SidebarGroupContent,
	SidebarGroupLabel,
	SidebarHeader,
	SidebarInput,
	SidebarInset,
	SidebarMenu,
	SidebarMenuAction,
	SidebarMenuBadge,
	SidebarMenuButton,
	SidebarMenuItem,
	SidebarMenuSkeleton,
	SidebarMenuSub,
	SidebarMenuSubButton,
	SidebarMenuSubItem,
	SidebarProvider,
	SidebarRail,
	SidebarSeparator,
	SidebarTrigger,
	useSidebar,
}
</file>

<file path="src/widgets/app-sidebar/ui/AppSidebar.tsx">
"use client"

import {
	Sidebar,
	SidebarContent,
	SidebarFooter,
	SidebarGroup,
	SidebarGroupContent,
	SidebarHeader,
	SidebarMenu,
	SidebarMenuButton,
	SidebarMenuItem,
} from "@/shared/ui/sidebar"
import UserWidget from "./UserWidget"
import ThemeToggle from "./ThemeToggle"
import Link from "next/link"
import {
	ImageIcon,
	LayoutDashboardIcon,
	GalleryVerticalEndIcon,
} from "lucide-react"
import Logo from "@/shared/ui/logo"

const navItems = [
	{
		title: "Главная",
		url: "/",
		icon: LayoutDashboardIcon,
	},
	{
		title: "Создать мем",
		url: "/create",
		icon: ImageIcon,
	},
	{
		title: "Галерея",
		url: "/gallery",
		icon: GalleryVerticalEndIcon,
	},
]

export function AppSidebar() {
	return (
		<Sidebar collapsible="icon">
			<SidebarHeader className="">
				<Link
					href="/"
					className="flex items-center gap-3 p-2 group-data-[collapsible=icon]:justify-center group-data-[collapsible=icon]:py-4"
				>
					<Logo className="size-4 shrink-0 scale-150" />
					<h1 className="font-pixelify-sans text-2xl transition-all group-data-[collapsible=icon]:hidden">
						Memelogy
					</h1>
				</Link>
				<div className="border-b-2 border-white/10" />
			</SidebarHeader>
			<SidebarContent>
				<SidebarGroup>
					<SidebarGroupContent>
						<SidebarMenu>
							{navItems.map((item) => (
								<SidebarMenuItem key={item.title}>
									<SidebarMenuButton asChild>
										<Link href={item.url}>
											<item.icon className="h-4 w-4" />
											<span className="font-pixelify-sans text-lg font-light">
												{item.title}
											</span>
										</Link>
									</SidebarMenuButton>
								</SidebarMenuItem>
							))}
						</SidebarMenu>
					</SidebarGroupContent>
				</SidebarGroup>
			</SidebarContent>
			<SidebarFooter>
				<UserWidget />
				<div className="flex w-full items-center justify-center">
					<ThemeToggle />
				</div>
			</SidebarFooter>
		</Sidebar>
	)
}
</file>

<file path="src/widgets/auth-layout/AuthLayout.tsx">
import { SidebarTrigger } from "@/shared/ui/sidebar"
import { ReactNode } from "react"

export default function Layout({ children }: { children: ReactNode }) {
	return (
		<div className="relative h-full w-full">
			<SidebarTrigger className="absolute top-4 left-4 size-8" />
			{children}
		</div>
	)
}
</file>

<file path="src/widgets/memes-list/ui/MemeCard.tsx">
import { IMemeDTO } from "@/entities/meme"
import { useGetUser } from "@/entities/user/api/useGetUser"
import { cn } from "@/shared/lib/utils"
import { AvatarFallback, AvatarImage, Avatar } from "@/shared/ui/avatar"
import { Button } from "@/shared/ui/button"
import { FrownIcon, Heart } from "lucide-react"
import Image from "next/image"
import { useState } from "react"

interface MemeCardProps extends React.HTMLAttributes<HTMLDivElement> {
	virtualRow: any
	leftPosition: number
	columnWidth: number
	scaledHeight: number
	GAP: number
	meme: IMemeDTO
}

export const MemeCard = ({
	virtualRow,
	leftPosition,
	columnWidth,
	scaledHeight,
	GAP,
	className,
	meme,
	...props
}: MemeCardProps) => {
	const [imageError, setImageError] = useState(!meme.imageUrl)
	return (
		<div
			style={{
				position: "absolute",
				top: 0,
				left: `${leftPosition}px`,
				width: `${columnWidth}px`,
				height: `${scaledHeight}px`,
				transform: `translateY(${virtualRow.start}px)`,
				padding: `0 0 ${GAP}px 0`,
			}}
			className={cn(
				"group relative cursor-pointer overflow-hidden rounded-2xl shadow-md transition-shadow duration-300 hover:shadow-2xl",
				className,
			)}
			{...props}
		>
			{!imageError && meme.imageUrl ? (
				<div className="h-full w-full">
					<Image
						src={meme.imageUrl}
						alt={meme.title}
						fill
						sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, (max-width: 1280px) 25vw, 20vw"
						className="object-cover transition-transform duration-300 group-hover:scale-105"
						priority={virtualRow.index < 6}
						loading={virtualRow.index < 6 ? undefined : "lazy"}
						onError={() => setImageError(true)}
					/>
				</div>
			) : (
				<div className="flex h-full w-full flex-col items-center justify-center">
					<FrownIcon className="text-muted-foreground/50 size-12" />
					<p className="text-muted-foreground/50 mt-2 text-center text-sm">
						Изображение не загрузилось
					</p>
				</div>
			)}

			<div className="absolute right-0 bottom-0 left-0 flex max-h-[35%] flex-col justify-end bg-gradient-to-t from-black/80 to-transparent p-4 opacity-0 transition-all group-hover:opacity-100">
				<div className="flex items-center gap-4">
					<Avatar>
						<AvatarFallback>
							{meme.author.slice(0, 2)}
						</AvatarFallback>
					</Avatar>
					<h3 className="line-clamp-3 text-lg font-bold text-white">
						{meme.title}
					</h3>
				</div>
			</div>
		</div>
	)
}
</file>

<file path="Dockerfile">
FROM oven/bun:1-alpine AS base
WORKDIR /app

FROM base AS deps
COPY package.json bun.lockb* ./
RUN bun install --frozen-lockfile

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED=1
ENV NODE_ENV=production

ARG NEXT_PUBLIC_API_URL
ENV NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL

RUN bun run build

FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

RUN addgroup -S nodejs && \
    adduser -S nextjs -G nodejs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["bun", "run", "server.js"]
</file>

<file path="README.md">
# AI Memes Frontend 🎭

Приложение для создания и обмена мемами, созданными с помощью ИИ. Построено на Next.js 15 с использованием MSW для API mocking и Faker.js для генерации тестовых данных.

## 🚀 Быстрый старт

```bash
# Установка зависимостей
npm install

# Запуск dev сервера
npm run dev
```

Откройте [http://localhost:3000](http://localhost:3000) в браузере.

## ✨ Возможности

- ✅ **Типизированный API** - OpenAPI TypeScript схема с автогенерацией
- ✅ **Гибридный режим** - Auth/Users на реальный бэкенд, остальное через MSW моки
- ✅ **MSW (Mock Service Worker)** - Перехват и мокирование API запросов
- ✅ **Faker.js** - Генерация реалистичных фейковых данных
- ✅ **TypeScript** - Полная типизация
- ✅ **React Query** - Умное кэширование и управление состоянием
- ✅ **Next.js 15** - App Router, Server Components
- ✅ **Tailwind CSS** - Стилизация

## 📁 Структура проекта

```
src/
├── app/                    # Next.js app router
│   ├── layout.tsx         # Root layout с MSW provider
│   └── page.tsx           # Главная страница
├── shared/
│   ├── api/               # 🎯 Типизированный API (OpenAPI)
│   │   ├── typed-client.ts    # openapi-fetch клиент
│   │   ├── auth.ts            # Auth API (реальный бэкенд)
│   │   ├── users.ts           # Users API (реальный бэкенд)
│   │   ├── hooks.ts           # React Query хуки
│   │   ├── config.ts          # Гибридная конфигурация
│   │   ├── api-schema.d.ts    # Автогенерируемые типы
│   │   └── README.md          # Документация API
│   ├── config/
│   │   └── routes.ts      # API и app роуты
│   ├── mocks/             # MSW конфигурация (только для мемов!)
│   │   ├── browser.ts    # MSW worker setup
│   │   └── handlers.ts   # API mock handlers
│   └── types/
│       └── meme.ts        # TypeScript типы
├── entities/              # FSD: Бизнес сущности
├── features/              # FSD: Пользовательские действия
├── widgets/               # FSD: Композитные блоки
└── pages/                 # FSD: Страницы
```

## 🔧 Технологии

- **Framework**: Next.js 15.5.4
- **Language**: TypeScript
- **Styling**: Tailwind CSS 4
- **Mocking**: MSW (Mock Service Worker)
- **Fake Data**: Faker.js
- **UI Components**: shadcn/ui (частично)

## 📚 Документация

### API (Типизированный, с OpenAPI)

- 📖 [API README](./src/shared/api/README.md) - Обзор
- 🚀 [Быстрый старт](./src/shared/api/QUICKSTART.md) - Примеры использования
- 📘 [Полный гайд](./src/shared/api/HYBRID_API_GUIDE.md) - Гибридный режим
- 🏗️ [Архитектура](./src/shared/api/ARCHITECTURE.md) - Диаграммы и схемы
- ✅ [Что готово](./src/shared/api/INTEGRATION_COMPLETE.md) - Статус интеграции

### Остальное

- 🎭 [MSW Setup](./MSW_SETUP.md) - Настройка Mock Service Worker

### Быстрый пример использования API

```typescript
// ✅ Новый способ (типизированный, реальный бэкенд)
import { useLogin, useRegister, useUserProfile } from '@/shared/api'

function LoginForm() {
  const { mutate: login, isPending } = useLogin()
  
  const handleSubmit = (credentials) => {
    login(credentials, {
      onSuccess: (auth) => console.log("Logged in!", auth.user)
    })
  }
}

function ProfilePage() {
  const { data: user, isLoading } = useUserProfile()
  
  if (isLoading) return <div>Loading...</div>
  return <div>Hello, {user?.username}</div>
}

// ⚠️ Старый способ (MSW моки, для мемов)
import { getMemes } from '@/shared/api/memes';

const memes = await getMemes({ page: 1, pageSize: 10 });
```

## 🎨 API эндпоинты

### ✅ Реальный бэкенд (localhost:8080)
- `POST /auth/login` - Вход
- `POST /auth/register` - Регистрация
- `POST /auth/logout` - Выход
- `POST /auth/refresh` - Обновление токена
- `GET /users/profile` - Профиль пользователя
- `PUT /users/profile/update` - Обновление профиля
- `GET /users/list` - Список пользователей
- `POST /users/change-password` - Изменение пароля

### 🎭 MSW Моки (localhost:3000)
- `GET /api/memes` - Список мемов
- `GET /api/memes/:id` - Мем по ID
- `POST /api/memes` - Создать мем
- `PATCH /api/memes/:id` - Обновить мем
- `DELETE /api/memes/:id` - Удалить мем
- `POST /api/memes/generate` - Генерация мема с AI

## 🛠️ Скрипты

```bash
npm run dev            # Запуск dev сервера с Turbopack
npm run build          # Сборка для production
npm run start          # Запуск production сервера
npm run lint           # Проверка кода с ESLint
npm run generate:api   # Обновить OpenAPI схему с бэкенда
```

## ⚙️ Конфигурация

Скопируйте `.env.example` в `.env.local`:

```bash
cp .env.example .env.local
```

Основные переменные:

```env
# URL реального бэкенда
NEXT_PUBLIC_API_URL=http://localhost:8080

# Режим: hybrid (рекомендуется) | mock | real
NEXT_PUBLIC_API_MODE=hybrid

# Включить MSW моки
NEXT_PUBLIC_MSW_ENABLED=true
```

## 📖 Дополнительно

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

### Полезные ресурсы

- [Next.js Documentation](https://nextjs.org/docs)
- [MSW Documentation](https://mswjs.io/)
- [Faker.js Documentation](https://fakerjs.dev/)
- [Tailwind CSS](https://tailwindcss.com/)

## 🚢 Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme).

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

:root {
	--background: oklch(1 0 0);
	--foreground: oklch(0.4513 0.0934 237.8578);
	--card: oklch(0.9702 0 0);
	--card-foreground: oklch(0.4513 0.0934 237.8578);
	--popover: oklch(1 0 0);
	--popover-foreground: oklch(0.4513 0.0934 237.8578);
	--primary: oklch(0.6254 0.1346 236.8943);
	--primary-foreground: oklch(1 0 0);
	--secondary: oklch(0.9067 0 0);
	--secondary-foreground: oklch(0.4513 0.0934 237.8578);
	--muted: oklch(0.9551 0 0);
	--muted-foreground: oklch(0.4495 0 0);
	--accent: oklch(0.8576 0 0);
	--accent-foreground: oklch(0.4513 0.0934 237.8578);
	--destructive: oklch(0.6636 0.2231 25.7269);
	--destructive-foreground: oklch(1 0 0);
	--border: oklch(0.8078 0 0);
	--input: oklch(0.931 0 0);
	--ring: oklch(0.6254 0.1346 236.8943);
	--chart-1: oklch(0.6254 0.1346 236.8943);
	--chart-2: oklch(0.4513 0.0934 237.8578);
	--chart-3: oklch(0.787 0.1124 249.7946);
	--chart-4: oklch(0.5867 0.1174 250.1702);
	--chart-5: oklch(0.8935 0.0546 247.5979);
	--sidebar: oklch(0.4513 0.0934 237.8578);
	--sidebar-foreground: oklch(1 0 0);
	--sidebar-primary: oklch(0.6254 0.1346 236.8943);
	--sidebar-primary-foreground: oklch(1 0 0);
	--sidebar-accent: oklch(0.8576 0 0);
	--sidebar-accent-foreground: oklch(0.4513 0.0934 237.8578);
	--sidebar-border: oklch(0.787 0.1124 249.7946);
	--sidebar-ring: oklch(0.6254 0.1346 236.8943);
	--font-sans: Alan Sans, ui-sans-serif, sans-serif, system-ui;
	--font-serif: Alegreya SC, ui-serif, serif;
	--font-mono: Montserrat Alternates, ui-sans-serif, sans-serif, system-ui;
	--radius: 1rem;
	--shadow-x: 2px;
	--shadow-y: 2px;
	--shadow-blur: 0px;
	--shadow-spread: 0px;
	--shadow-opacity: 0.4;
	--shadow-color: #105e7f;
	--shadow-2xs: 2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.2);
	--shadow-xs: 2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.2);
	--shadow-sm:
		2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.4),
		2px 1px 2px -1px hsl(197.8378 77.6224% 28.0392% / 0.4);
	--shadow:
		2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.4),
		2px 1px 2px -1px hsl(197.8378 77.6224% 28.0392% / 0.4);
	--shadow-md:
		2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.4),
		2px 2px 4px -1px hsl(197.8378 77.6224% 28.0392% / 0.4);
	--shadow-lg:
		2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.4),
		2px 4px 6px -1px hsl(197.8378 77.6224% 28.0392% / 0.4);
	--shadow-xl:
		2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 0.4),
		2px 8px 10px -1px hsl(197.8378 77.6224% 28.0392% / 0.4);
	--shadow-2xl: 2px 2px 0px 0px hsl(197.8378 77.6224% 28.0392% / 1);
	--tracking-normal: 0.05em;
	--spacing: 0.25rem;
}

.dark {
	--background: oklch(0.4513 0.0934 237.8578);
	--foreground: oklch(1 0 0);
	--card: oklch(0.3345 0.0661 236.7426);
	--card-foreground: oklch(1 0 0);
	--popover: oklch(0.3345 0.0661 236.7426);
	--popover-foreground: oklch(1 0 0);
	--primary: oklch(0.6254 0.1346 236.8943);
	--primary-foreground: oklch(1 0 0);
	--secondary: oklch(0.3345 0.0661 236.7426);
	--secondary-foreground: oklch(1 0 0);
	--muted: oklch(0.3976 0.0784 235.1309);
	--muted-foreground: oklch(0.8576 0 0);
	--accent: oklch(0.3976 0.0784 235.1309);
	--accent-foreground: oklch(1 0 0);
	--destructive: oklch(0.7044 0.1872 23.1858);
	--destructive-foreground: oklch(1 0 0);
	--border: oklch(0.3976 0.0784 235.1309);
	--input: oklch(0.3976 0.0784 235.1309);
	--ring: oklch(0.6254 0.1346 236.8943);
	--chart-1: oklch(0.6254 0.1346 236.8943);
	--chart-2: oklch(0.787 0.1124 249.7946);
	--chart-3: oklch(0.5867 0.1174 250.1702);
	--chart-4: oklch(0.8935 0.0546 247.5979);
	--chart-5: oklch(0.6891 0.1145 249.4541);
	--sidebar: oklch(0.3345 0.0661 236.7426);
	--sidebar-foreground: oklch(1 0 0);
	--sidebar-primary: oklch(0.6254 0.1346 236.8943);
	--sidebar-primary-foreground: oklch(1 0 0);
	--sidebar-accent: oklch(0.3976 0.0784 235.1309);
	--sidebar-accent-foreground: oklch(1 0 0);
	--sidebar-border: oklch(0.3976 0.0784 235.1309);
	--sidebar-ring: oklch(0.6254 0.1346 236.8943);
	--font-sans: Alan Sans, ui-sans-serif, sans-serif, system-ui;
	--font-serif: Alegreya SC, ui-serif, serif;
	--font-mono: Montserrat Alternates, ui-sans-serif, sans-serif, system-ui;
	--radius: 1rem;
	--shadow-x: 2px;
	--shadow-y: 2px;
	--shadow-blur: 0px;
	--shadow-spread: 0px;
	--shadow-opacity: 0.4;
	--shadow-color: #000000;
	--shadow-2xs: 2px 2px 0px 0px hsl(0 0% 0% / 0.2);
	--shadow-xs: 2px 2px 0px 0px hsl(0 0% 0% / 0.2);
	--shadow-sm:
		2px 2px 0px 0px hsl(0 0% 0% / 0.4), 2px 1px 2px -1px hsl(0 0% 0% / 0.4);
	--shadow:
		2px 2px 0px 0px hsl(0 0% 0% / 0.4), 2px 1px 2px -1px hsl(0 0% 0% / 0.4);
	--shadow-md:
		2px 2px 0px 0px hsl(0 0% 0% / 0.4), 2px 2px 4px -1px hsl(0 0% 0% / 0.4);
	--shadow-lg:
		2px 2px 0px 0px hsl(0 0% 0% / 0.4), 2px 4px 6px -1px hsl(0 0% 0% / 0.4);
	--shadow-xl:
		2px 2px 0px 0px hsl(0 0% 0% / 0.4), 2px 8px 10px -1px hsl(0 0% 0% / 0.4);
	--shadow-2xl: 2px 2px 0px 0px hsl(0 0% 0% / 1);
}

@theme inline {
	--font-montserrat: var(--font-montserrat);
	--font-pixelify-sans: var(--font-pixelify-sans);

	--color-background: var(--background);
	--color-foreground: var(--foreground);
	--color-card: var(--card);
	--color-card-foreground: var(--card-foreground);
	--color-popover: var(--popover);
	--color-popover-foreground: var(--popover-foreground);
	--color-primary: var(--primary);
	--color-primary-foreground: var(--primary-foreground);
	--color-secondary: var(--secondary);
	--color-secondary-foreground: var(--secondary-foreground);
	--color-muted: var(--muted);
	--color-muted-foreground: var(--muted-foreground);
	--color-accent: var(--accent);
	--color-accent-foreground: var(--accent-foreground);
	--color-destructive: var(--destructive);
	--color-destructive-foreground: var(--destructive-foreground);
	--color-border: var(--border);
	--color-input: var(--input);
	--color-ring: var(--ring);
	--color-chart-1: var(--chart-1);
	--color-chart-2: var(--chart-2);
	--color-chart-3: var(--chart-3);
	--color-chart-4: var(--chart-4);
	--color-chart-5: var(--chart-5);
	--color-sidebar: var(--sidebar);
	--color-sidebar-foreground: var(--sidebar-foreground);
	--color-sidebar-primary: var(--sidebar-primary);
	--color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
	--color-sidebar-accent: var(--sidebar-accent);
	--color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
	--color-sidebar-border: var(--sidebar-border);
	--color-sidebar-ring: var(--sidebar-ring);

	--font-sans: var(--font-sans);
	--font-mono: var(--font-mono);
	--font-serif: var(--font-serif);

	--radius-sm: calc(var(--radius) - 4px);
	--radius-md: calc(var(--radius) - 2px);
	--radius-lg: var(--radius);
	--radius-xl: calc(var(--radius) + 4px);

	--shadow-2xs: var(--shadow-2xs);
	--shadow-xs: var(--shadow-xs);
	--shadow-sm: var(--shadow-sm);
	--shadow: var(--shadow);
	--shadow-md: var(--shadow-md);
	--shadow-lg: var(--shadow-lg);
	--shadow-xl: var(--shadow-xl);
	--shadow-2xl: var(--shadow-2xl);

	--tracking-tighter: calc(var(--tracking-normal) - 0.05em);
	--tracking-tight: calc(var(--tracking-normal) - 0.025em);
	--tracking-normal: var(--tracking-normal);
	--tracking-wide: calc(var(--tracking-normal) + 0.025em);
	--tracking-wider: calc(var(--tracking-normal) + 0.05em);
	--tracking-widest: calc(var(--tracking-normal) + 0.1em);
}

body {
	letter-spacing: var(--tracking-normal);
}

@layer base {
	* {
		@apply border-border outline-ring/50;
	}
	body {
		@apply bg-background text-foreground;
		font-family: var(--font-montserrat);
	}
}

/* @layer utilities {
    .content-auto {
        content-visibility: auto;
    }

    .contain-intrinsic-auto {
        contain-intrinsic-size: auto 400px;
    }
} */
</file>

<file path="src/app/providers.tsx">
"use client"

import { AppSidebar } from "@/widgets/app-sidebar"
import { SidebarInset, SidebarProvider } from "@/shared/ui/sidebar"
import {
	MutationCache,
	QueryCache,
	QueryClient,
	QueryClientProvider,
} from "@tanstack/react-query"
import { NuqsAdapter } from "nuqs/adapters/next"
import { useState } from "react"
import { Toaster } from "@/shared/ui/sonner"
import { customToast } from "@/shared/lib/utils"
import { ThemeProvider } from "next-themes"

export function Providers({ children }: { children: React.ReactNode }) {
	const [queryClient] = useState(
		() =>
			new QueryClient({
				queryCache: new QueryCache({
					onError: (error, query) => {
						if (query.state.data !== undefined) {
							customToast(
								`Ошибка обновления: ${error.message}`,
								"error",
							)
							return
						}

						// 2. Не показываем ошибки для запроса user (его обрабатываем локально для авторизации)
						if (query.queryKey[0] === "user") {
							return
						}
					},
				}),
				mutationCache: new MutationCache({
					onError: (error, _variables, _context, mutation) => {
						// Можно использовать meta для условной обработки
						if (mutation.meta?.hideErrorToast) {
							return
						}

						customToast(`Ошибка: ${error.message}`, "error")
					},
				}),
				defaultOptions: {
					queries: {
						staleTime: 60 * 1000, // 1 минута
						refetchOnWindowFocus: false,
						retry: 2,
					},
				},
			}),
	)

	return (
		<QueryClientProvider client={queryClient}>
			<ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
				<NuqsAdapter>
					<SidebarProvider>
						<AppSidebar />
						<SidebarInset>
							<div className="bg-primary-foreground dark:bg-foreground/1 h-full w-full">
								{children}
							</div>
						</SidebarInset>
					</SidebarProvider>
				</NuqsAdapter>
				<Toaster />
			</ThemeProvider>
		</QueryClientProvider>
	)
}
</file>

<file path="src/entities/meme/ui/MemeCard.tsx">
import { Card, CardContent, CardFooter } from "@/shared/ui/card"
import Image from "next/image"
import { formatDistanceToNow } from "date-fns"
import { ru } from "date-fns/locale"
import { Badge } from "@/shared/ui/badge"
import { IMemeDTO } from "../model/types"

interface MemeCardProps {
	meme: IMemeDTO
	onClick?: (meme: IMemeDTO) => void
}

export function MemeCard({ meme, onClick }: MemeCardProps) {
	const isProcessing =
		meme.status.toLowerCase() === "pending" ||
		meme.status.toLowerCase() === "started" ||
		meme.status.toLowerCase() === "processing"
	const isFailed = meme.status.toLowerCase() === "failed"

	return (
		<Card
			className="cursor-pointer overflow-hidden transition-shadow hover:shadow-lg"
			onClick={() => onClick?.(meme)}
		>
			<CardContent className="relative aspect-square p-0">
				{meme.imageUrl && meme.status === "completed" ? (
					<Image
						src={meme.imageUrl}
						alt={meme.title || "Meme"}
						fill
						className="object-cover"
						sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
					/>
				) : (
					<div className="bg-muted flex h-full w-full items-center justify-center">
						<Badge variant={isFailed ? "destructive" : "secondary"}>
							{isProcessing ? "Генерация..." : "Ошибка"}
						</Badge>
					</div>
				)}
			</CardContent>
			<CardFooter className="flex flex-col items-start gap-2 p-4">
				<p className="font-montserrat line-clamp-2 text-sm font-medium">
					{meme.title || "Без текста"}
				</p>
				<div className="flex w-full items-center justify-between">
					<p className="text-muted-foreground font-montserrat text-xs">
						{formatDistanceToNow(
							new Date(meme.createdAt || new Date()),
							{
								addSuffix: true,
								locale: ru,
							},
						)}
					</p>
					{meme.style && (
						<Badge variant="outline" className="text-xs">
							{meme.style}
						</Badge>
					)}
				</div>
			</CardFooter>
		</Card>
	)
}
</file>

<file path="src/pages/login/api/useLogin.ts">
import { LoginRequest, loginUser } from "@/shared/api"
import { useMutation, useQueryClient } from "@tanstack/react-query"

export const useLogin = () => {
	const queryClient = useQueryClient()

	return useMutation({
		mutationKey: ["login"],
		mutationFn: async (body: LoginRequest) => {
			const { data, error } = await loginUser(body)

			if (error) {
				throw new Error(
					error.error || "Login failed. Please try again.",
				)
			}

			return data
		},
		onSuccess: (authResponse) => {
			if (authResponse?.user) {
				queryClient.setQueryData(["user"], authResponse.user)
			}
		},
	})
}
</file>

<file path="src/shared/api/client.ts">
/**
 * Legacy API клиент для обратной совместимости
 *
 * РЕКОМЕНДАЦИЯ: Используйте типизированный клиент из typed-client.ts
 * для полной типобезопасности и автокомплита.
 *
 * @deprecated Используйте typedApiClient из @/shared/api/typed-client
 * @see src/shared/api/typed-client.ts
 * @see src/shared/api/README.md
 */

export interface RequestOptions extends RequestInit {
	params?: Record<string, string | number | boolean>
}

export class ApiError extends Error {
	constructor(
		message: string,
		public status: number,
		public data?: unknown,
	) {
		super(message)
		this.name = "ApiError"
	}
}

// Перехватчик refresh: одна попытка обновления при 401
let refreshing = false
let refreshPromise: Promise<void> | null = null

async function tryRefresh(): Promise<void> {
	if (refreshing && refreshPromise) return refreshPromise
	refreshing = true
	refreshPromise = fetch("/auth/refresh", {
		method: "POST",
		credentials: "include",
	})
		.then(async (res) => {
			if (!res.ok) throw new Error("refresh_failed")
		})
		.finally(() => {
			refreshing = false
			refreshPromise = null
		})
	return refreshPromise
}

// Универсальная обёртка вокруг fetch; совместима с типами из `api-schema.d.ts`
export async function apiFetch<T = unknown>(
	url: string,
	options: RequestOptions = {},
): Promise<T> {
	const { params, headers, ...rest } = options
	let fullUrl = url
	if (params) {
		const sp = new URLSearchParams()
		Object.entries(params).forEach(([k, v]) => sp.append(k, String(v)))
		fullUrl = `${url}?${sp.toString()}`
	}

	const config: RequestInit = {
		credentials: "include",
		headers: { "Content-Type": "application/json", ...headers },
		...rest,
	}

	const res = await fetch(fullUrl, config)
	if (res.status === 401) {
		try {
			await tryRefresh()
		} catch {
			// редирект на /auth на стороне вызова
			throw new ApiError("Unauthorized", 401)
		}
		const retry = await fetch(fullUrl, config)
		if (!retry.ok) {
			const data = await retry.json().catch(() => null)
			throw new ApiError(
				data?.message || `HTTP ${retry.status}`,
				retry.status,
				data,
			)
		}
		return retry.status === 204 ? ({} as T) : ((await retry.json()) as T)
	}
	if (!res.ok) {
		const data = await res.json().catch(() => null)
		throw new ApiError(
			data?.message || `HTTP ${res.status}`,
			res.status,
			data,
		)
	}
	return res.status === 204 ? ({} as T) : ((await res.json()) as T)
}

// Сохранить прежний экспортный интерфейс для существующих вызовов
export const apiClient = {
	get: <T = unknown>(url: string, options?: RequestOptions) =>
		apiFetch<T>(url, { ...options, method: "GET" }),
	post: <T = unknown>(
		url: string,
		data?: unknown,
		options?: RequestOptions,
	) =>
		apiFetch<T>(url, {
			...options,
			method: "POST",
			body: data ? JSON.stringify(data) : undefined,
		}),
	put: <T = unknown>(url: string, data?: unknown, options?: RequestOptions) =>
		apiFetch<T>(url, {
			...options,
			method: "PUT",
			body: data ? JSON.stringify(data) : undefined,
		}),
	patch: <T = unknown>(
		url: string,
		data?: unknown,
		options?: RequestOptions,
	) =>
		apiFetch<T>(url, {
			...options,
			method: "PATCH",
			body: data ? JSON.stringify(data) : undefined,
		}),
	delete: <T = unknown>(url: string, options?: RequestOptions) =>
		apiFetch<T>(url, { ...options, method: "DELETE" }),
}

export default apiClient
</file>

<file path="src/shared/api/memes.ts">
/**
 * API методы для работы с мемами
 * Использует типизированный клиент из typed-client.ts
 */

import { typedApiClient } from "./typed-client"

/**
 * Получить список мемов текущего пользователя
 */
export async function getMyMemes(params?: { limit?: number; offset?: number }) {
	const { data, error } = await typedApiClient.GET("/memes/my", {
		params: {
			query: params,
		},
	})

	if (error) throw new Error(error.error || "Failed to fetch user memes")

	return data
}

/**
 * Получить мем по ID
 */
export async function getMemeById(id: string) {
	const { data, error } = await typedApiClient.GET("/memes/{id}", {
		params: {
			path: { id },
		},
	})

	if (error) throw new Error(error.error || "Failed to fetch meme")
	return data
}

/**
 * Генерация мема через нейросеть
 */
export async function generateMeme(params: {
	prompt: string
	style?: string
	is_public?: boolean
}) {
	const { data, error } = await typedApiClient.POST("/memes/generate", {
		body: params,
	})

	if (error) throw new Error(error.error || "Failed to generate meme")
	return data
}

/**
 * Проверить статус генерации мема
 */
export async function getMemeStatus(id: string) {
	const { data, error } = await typedApiClient.GET("/memes/{id}/status", {
		params: {
			path: { id },
		},
	})

	if (error) throw new Error(error.error || "Failed to get meme status")
	return data
}

/**
 * Получить доступные стили для генерации
 */
export async function getAvailableStyles() {
	const { data, error } = await typedApiClient.GET("/memes/styles")

	if (error) throw new Error(error.error || "Failed to fetch styles")
	return data
}

/**
 * Удалить мем
 */
export async function deleteMeme(id: string) {
	const { data, error } = await typedApiClient.DELETE("/memes/{id}", {
		params: {
			path: { id },
		},
	})

	if (error) throw new Error(error.error || "Failed to delete meme")
	return data
}
</file>

<file path="src/shared/ui/authCard.tsx">
import { Card } from "@/shared/ui/card"
import { cn } from "../lib/utils"
import Logo from "./logo"

export default function AuthCard({
	isRegister = false,
}: {
	isRegister?: boolean
}) {
	return (
		<div
			className={cn(
				"hidden items-center justify-center p-12 lg:flex lg:w-1/2 lg:justify-end",
				{
					"lg:justify-start": isRegister,
				},
			)}
		>
			<Card
				className="bg-background flex w-full max-w-md flex-col justify-between gap-3 rounded-3xl border-3 p-4 text-white"
				style={{
					width: "clamp(200px, 50vh, 500px)",
				}}
			>
				<div className="from-primary to-secondary-foreground dark:from-primary dark:to-secondary flex h-full flex-3 flex-col justify-end rounded-2xl bg-gradient-to-br p-4 dark:border">
					{/* <CircleIcon className="size-20" /> */}
					<div className="space-y-6">
						<h2 className="font-pixelify-sans text-4xl font-normal tracking-widest md:text-5xl">
							Думай
							<br />
							Генерируй
							<br />
							Смеши
						</h2>
					</div>
					<div className="flex items-center justify-between">
						{/* <MedicineIcon className="size-24 animate-spin [animation-duration:12s]" />
						<StarIcon className="size-24" /> */}
					</div>
				</div>

				<div className="font-pixelify-sans text-primary flex items-center gap-3 text-4xl font-extrabold dark:text-white">
					<Logo className="fill-accent size-10 dark:fill-white" />
					<h2>MemoLogy</h2>
				</div>
			</Card>
		</div>
	)
}
</file>

<file path="src/widgets/memes-list/ui/MemesList.tsx">
"use client"

import useIntersectionObserver from "@/shared/hooks/use-intersection-observer"
import { apiClient } from "@/shared/api/client"
import { API_ROUTES } from "@/shared/config/routes"
import { useInfiniteQuery } from "@tanstack/react-query"
import Image from "next/image"
import React, { useEffect, useRef } from "react"
import CardsSkeleton from "@/widgets/memes-list/ui/cards-skeleton"
import { useVirtualizer } from "@tanstack/react-virtual"
import { useElementSize } from "@/shared/hooks"
import { MemeCard } from "./MemeCard"
import { IMemeListDTO, MemesListDTO } from "@/entities/meme"
import { MemeListResponse } from "@/entities/meme/model/types"

interface MemesListProps {
	initialData: IMemeListDTO
	search: string
}

export function MemesList({ initialData, search }: MemesListProps) {
	const { data, isFetching, isLoading, fetchNextPage, hasNextPage } =
		useInfiniteQuery<IMemeListDTO>({
			queryKey: ["memes", search],
			queryFn: async (context) => {
				const signal = context.signal

				const data = await apiClient.get<MemeListResponse>(
					API_ROUTES.MEMES.LIST,
					{
						params: {
							page: context.pageParam as number,
							limit: 30,
							...(search && { search }),
						},
						signal,
					},
				)
				const transformedData = MemesListDTO.fromApi(data)
				return transformedData
			},
			initialData: {
				pages: [initialData],
				pageParams: [1],
			},
			initialPageParam: 1,
			getNextPageParam: (lastPage, allPages) => {
				const morePagesExist =
					lastPage.page * lastPage.limit < lastPage.total
				if (!morePagesExist) return undefined
				return allPages.length + 1
			},
		})

	const allMemes = data ? data.pages.flatMap((page) => page.data) : []

	const dividerForInfScroll = useRef<HTMLDivElement>(null)
	const parentRef = useRef<HTMLDivElement>(null)
	const { value } = useElementSize(parentRef)
	const [delayWindowSize, setDelayWindowSize] = React.useState(value)

	useEffect(() => {
		setDelayWindowSize(value)
	}, [value])

	const LANES = React.useMemo(() => {
		const width = delayWindowSize.width || 1200
		if (width < 640) return 1 // mobile
		if (width < 768) return 1 // tablet
		if (width < 1024) return 2 // small desktop
		if (width < 1280) return 3 // medium desktop
		if (width < 1536) return 4 // large desktop
		return 5 // xl desktop (>= 1536px)
	}, [delayWindowSize.width])

	useIntersectionObserver((entries) => {
		const entry = entries[0]
		if (entry?.isIntersecting && hasNextPage && !isFetching) {
			fetchNextPage()
		}
	}, dividerForInfScroll)

	const GAP = 8 // gap between cards in pixels
	const rowVirtualizer = useVirtualizer({
		count:
			data?.pages.reduce((acc, page) => acc + page.data.length, 0) || 0,
		getScrollElement: () => parentRef.current,
		estimateSize: (i: number) => {
			const meme = allMemes[i]
			if (!meme?.width || !meme?.height) return 400
			const aspectRatio = meme.width / meme.height
			const containerWidth = parentRef.current?.clientWidth || 1200
			const totalGapWidth = GAP * (LANES + 1)
			const columnWidth = (containerWidth - totalGapWidth) / LANES
			return columnWidth / aspectRatio + GAP
		},
		overscan: 5,
		lanes: LANES,
	})

	React.useEffect(() => {
		rowVirtualizer.measure()
	}, [LANES, delayWindowSize, rowVirtualizer])

	if (isFetching && !data) {
		return <CardsSkeleton />
	}

	return (
		<div className="mt-4 h-screen w-full overflow-auto" ref={parentRef}>
			<div
				style={{
					height: `${rowVirtualizer.getTotalSize()}px`,
					width: "100%",
					position: "relative",
				}}
			>
				{rowVirtualizer.getVirtualItems().map((virtualRow: any) => {
					const meme = allMemes[virtualRow.index]
					if (!meme) return null

					const containerWidth =
						parentRef.current?.clientWidth || 1200
					const totalGapWidth = GAP * (LANES + 1)
					const columnWidth = (containerWidth - totalGapWidth) / LANES
					const aspectRatio = meme.width / meme.height
					const scaledHeight = columnWidth / aspectRatio

					const leftPosition =
						GAP + virtualRow.lane * (columnWidth + GAP)

					return (
						<MemeCard
							virtualRow={virtualRow}
							leftPosition={leftPosition}
							columnWidth={columnWidth}
							scaledHeight={scaledHeight}
							GAP={GAP}
							meme={meme}
							key={virtualRow.index}
						/>
					)
				})}
			</div>

			{((isFetching && hasNextPage) || isLoading) && (
				<div className="mt-4 w-full">
					<CardsSkeleton columns={LANES} />
				</div>
			)}
			<div className="h-1 w-full" ref={dividerForInfScroll}></div>
		</div>
	)
}
</file>

<file path="tsconfig.json">
{
	"compilerOptions": {
		"target": "ES2017",
		"lib": ["dom", "dom.iterable", "esnext"],
		"allowJs": true,
		"skipLibCheck": true,
		"strict": true,
		"noEmit": true,
		"esModuleInterop": true,
		"module": "esnext",
		"moduleResolution": "bundler",
		"resolveJsonModule": true,
		"isolatedModules": true,
		"jsx": "preserve",
		"incremental": true,
		"noUncheckedIndexedAccess": true,
		"plugins": [
			{
				"name": "next"
			}
		],
		"paths": {
			"@/*": ["./src/*"]
		}
	},
	"include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
	"exclude": ["node_modules", ".next/types/validator.ts"]
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

memology-backend/

# bun
.bun

.github/prompts
# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (НЕ коммитим секреты, но коммитим .env.production.example)
.env
.env*.local
.env.production

# НО коммитим примеры
!.env.production.example

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="docker-compose.yml">
version: "3.8"

services:
    frontend:
        build:
            context: .
            dockerfile: Dockerfile
            args:
                NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-https://memology.pixel-team.ru/api/v1}
        container_name: ai-memes-frontend

        ports:
            - "3030:3000"

        environment:
            - NODE_ENV=production
            - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-https://memology.pixel-team.ru/api/v1}

        restart: unless-stopped

        healthcheck:
            test:
                [
                    "CMD",
                    "node",
                    "-e",
                    "require('http').get('http://localhost:3000', (r) => process.exit(r.statusCode === 200 ? 0 : 1))",
                ]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 40s
</file>

<file path="src/shared/api/api-schema.d.ts">
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * User login
         * @description Login with username or email and password
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Login credentials */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["services.LoginRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["services.AuthResponse"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout user
         * @description Logout user and invalidate refresh token from cookies
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MessageResponse"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout-all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout from all devices
         * @description Logout user from all devices
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MessageResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh access token
         * @description Get new access token using refresh token from cookies
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["services.AuthResponse"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register new user
         * @description Register a new user account
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Registration data */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["services.RegisterRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["services.AuthResponse"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Conflict */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all memes
         * @description Get paginated list of all memes (admin only)
         */
        get: {
            parameters: {
                query?: {
                    /** @description Page number */
                    page?: number;
                    /** @description Items per page */
                    limit?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MemeHistoryResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate new meme
         * @description Generate meme from user input using neural network. Style and is_public are optional. Returns meme with pending status and task_id for checking progress. By default, memes are public.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Meme generation request */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["services.CreateMemeRequest"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.Meme"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/my": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user memes
         * @description Get list of memes created by current user with pagination
         */
        get: {
            parameters: {
                query?: {
                    /** @description Page number */
                    page?: number;
                    /** @description Items per page */
                    limit?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MemeHistoryResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/public": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get public memes
         * @description Get paginated list of public memes
         */
        get: {
            parameters: {
                query?: {
                    /** @description Page number */
                    page?: number;
                    /** @description Items per page */
                    limit?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MemeHistoryResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/search/private": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search private memes
         * @description Search memes created by the authorized user by query string
         */
        get: {
            parameters: {
                query: {
                    /** @description Search query */
                    q: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.Meme"][];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/search/public": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search public memes
         * @description Search memes among public ones by query string
         */
        get: {
            parameters: {
                query: {
                    /** @description Search query */
                    q: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.Meme"][];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/styles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get available meme styles
         * @description Get list of available meme generation styles from neural network
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string[];
                    };
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get meme by ID
         * @description Get meme details by ID. Private memes can only be viewed by their owner.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Meme ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.Meme"];
                    };
                };
                /** @description Forbidden */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        /**
         * Delete meme
         * @description Delete meme by ID (only owner can delete)
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Meme ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MessageResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/memes/{id}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check meme generation status
         * @description Check if meme generation is completed and fetch result if ready
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Meme ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.Meme"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/account": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete user account
         * @description Delete current user account and all associated data
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MessageResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Internal Server Error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/change-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Change password
         * @description Change user password
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Password change data */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["services.ChangePasswordRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.MessageResponse"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get users list
         * @description Get paginated users list
         */
        get: {
            parameters: {
                query?: {
                    /** @description Limit */
                    limit?: number;
                    /** @description Offset */
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.User"][];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user profile
         * @description Get current user profile
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.User"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/profile/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update user profile
         * @description Update current user profile
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Profile update data */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["services.UpdateProfileRequest"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.User"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Conflict */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/profile/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user profile by id
         * @description Get user profile by id
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description User ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["models.User"];
                    };
                };
                /** @description Unauthorized */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
                /** @description Not Found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["handlers.ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        "handlers.ErrorResponse": {
            error?: string;
        };
        "handlers.MemeHistoryResponse": {
            limit?: number;
            memes?: components["schemas"]["models.Meme"][];
            page?: number;
            total?: number;
        };
        "handlers.MessageResponse": {
            message?: string;
        };
        "models.Meme": {
            aspect_ratio?: string;
            created_at?: string;
            generation_time_ms?: number;
            height?: number;
            id?: string;
            image_url?: string;
            is_public?: boolean;
            metrics?: components["schemas"]["models.MemeMetrics"];
            prompt?: string;
            status?: string;
            style?: string;
            task_id?: string;
            updated_at?: string;
            user_id?: string;
            width?: number;
        };
        "models.MemeMetrics": {
            click_count?: number;
            created_at?: string;
            download_count?: number;
            id?: string;
            meme_id?: string;
            other_interactions?: number;
            rating_score?: number;
            updated_at?: string;
        };
        "models.User": {
            avatar_url?: string;
            created_at?: string;
            email?: string;
            id?: string;
            is_active?: boolean;
            updated_at?: string;
            username: string;
        };
        "services.AuthResponse": {
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... */
            access_token?: string;
            /** @example 3600 */
            expires_in?: number;
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... */
            refresh_token?: string;
            user?: components["schemas"]["models.User"];
        };
        "services.ChangePasswordRequest": {
            /** @example oldpassword */
            current_password: string;
            /** @example newpassword123 */
            new_password: string;
        };
        "services.CreateMemeRequest": {
            /** @example true */
            is_public?: boolean;
            /** @example я купил компьютер за 1000000 */
            prompt: string;
            /** @example anime */
            style?: string;
        };
        "services.LoginRequest": {
            /** @example password123 */
            password: string;
            /** @example johndoe или john@example.com */
            username: string;
        };
        "services.RegisterRequest": {
            /** @example john@example.com */
            email: string;
            /** @example password123 */
            password: string;
            /** @example johndoe */
            username: string;
        };
        "services.UpdateProfileRequest": {
            /** @example john.new@example.com */
            email?: string;
            /** @example johndoe_new */
            username?: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
</file>

<file path="src/pages/login/ui/LoginPage.tsx">
"use client"

import { Button } from "@/shared/ui/button"
import { Field, FieldError, FieldGroup } from "@/shared/ui/field"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import InputLabel from "@/shared/ui/inputLabel"
import { useLogin } from "../api/useLogin"
import { customToast } from "@/shared/lib/utils"
import { LoginForm, loginSchema } from "../model/login.model"
import { useRouter } from "next/navigation"
import Link from "next/link"
import AuthCard from "@/shared/ui/authCard"

export default function LoginPage() {
	const navigate = useRouter()

	const {
		register,
		handleSubmit,
		formState: { errors, dirtyFields },
	} = useForm<LoginForm>({
		resolver: zodResolver(loginSchema),
		defaultValues: {
			emailOrUsername: "",
			password: "",
		},
	})

	const mutateLogin = useLogin()

	const onSubmit = (data: LoginForm) => {
		const fetchData = {
			username: data.emailOrUsername,
			password: data.password,
		}
		mutateLogin.mutate(fetchData, {
			onSuccess: (data) => {
				customToast("Login successful!", "success")
				console.log("Login success:", data)
				navigate.replace("/")
				navigate.refresh()
			},
		})
	}

	console.log(dirtyFields)

	return (
		<div className="flex h-full items-center justify-center">
			<AuthCard />

			{/* Right Side - Form */}
			<div className="flex flex-1 items-center justify-center p-6 lg:justify-start lg:p-12">
				<div className="w-full max-w-md space-y-8">
					<div className="space-y-2 text-center">
						<h1 className="font-pixelify text-4xl font-bold">
							Welcome Back
						</h1>
						<p className="text-muted-foreground">
							Log in to access your meme dashboard
						</p>
					</div>

					<form
						onSubmit={handleSubmit(onSubmit)}
						className="space-y-6"
					>
						<FieldGroup className="gap-4">
							<Field data-invalid={!!errors.emailOrUsername}>
								<div className="relative">
									<InputLabel
										type="email"
										placeholder=" "
										aria-invalid={!!errors.emailOrUsername}
										className="peer pt-6"
										label="Email"
										{...register("emailOrUsername")}
									/>
								</div>
								{errors.emailOrUsername && (
									<FieldError>
										{errors.emailOrUsername.message}
									</FieldError>
								)}
							</Field>

							<Field data-invalid={!!errors.password}>
								<div className="relative">
									<InputLabel
										type="password"
										placeholder=" "
										aria-invalid={!!errors.password}
										className="peer pt-6"
										label="Password"
										{...register("password")}
									/>
								</div>
								{errors.password && (
									<FieldError>
										{errors.password.message}
									</FieldError>
								)}
							</Field>
						</FieldGroup>

						<Button
							type="submit"
							className="bg-primary hover:bg-primary/90 h-12 w-full rounded-xl text-lg font-semibold text-white"
							disabled={mutateLogin.isPending}
						>
							{mutateLogin.isPending ? "Logging in..." : "Login"}
						</Button>

						<div className="flex items-center justify-center gap-2 pt-4">
							<hr className="border-muted-foreground flex-1 border-t-2" />
							<span className="text-muted-foreground text-sm">
								Doesn't have an account?
							</span>
							<Link
								href="/auth/register"
								className="hover:text-primary text-secondary-foreground text-sm font-semibold underline transition-colors duration-200"
							>
								Register
							</Link>
							<hr className="border-muted-foreground flex-1 border-t-2" />
						</div>
					</form>
				</div>
			</div>
		</div>
	)
}
</file>

<file path="src/pages/register/ui/RegisterPage.tsx">
"use client"

import { Button } from "@/shared/ui/button"
import { Field, FieldError, FieldGroup } from "@/shared/ui/field"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import InputLabel from "@/shared/ui/inputLabel"
import { useRegister } from "../api/useRegister"
import { customToast } from "@/shared/lib/utils"
import { RegisterForm, registerSchema } from "../model/register.model"
import { useRouter } from "next/navigation"
import Link from "next/link"
import AuthCard from "@/shared/ui/authCard"

export default function RegisterPage() {
	const navigate = useRouter()

	const {
		register,
		handleSubmit,
		formState: { errors, dirtyFields },
	} = useForm<RegisterForm>({
		resolver: zodResolver(registerSchema),
		defaultValues: {
			username: "",
			email: "",
			password: "",
			confirmPassword: "",
		},
	})

	const mutateRegister = useRegister()

	const onSubmit = (data: RegisterForm) => {
		mutateRegister.mutate(data, {
			onSuccess: (data) => {
				customToast("Registration successful!", "success")
				console.log("Register success:", data)
				navigate.replace("/")
				navigate.refresh()
			},
		})
	}

	console.log(dirtyFields)

	return (
		<div className="flex h-full items-center justify-center">
			<div className="flex flex-1 items-center justify-center p-6 lg:justify-end lg:p-12">
				<div className="w-full max-w-md space-y-8">
					<div className="space-y-2 text-center">
						<h1 className="font-pixelify text-4xl font-bold">
							Create Account
						</h1>
						<p className="text-muted-foreground font-montserrat">
							Join AI Meme Generator and start creating
						</p>
					</div>

					<form
						onSubmit={handleSubmit(onSubmit)}
						className="font-montserrat space-y-5"
					>
						<FieldGroup className="gap-4">
							<Field data-invalid={!!errors.username}>
								<div className="relative">
									<InputLabel
										type="text"
										placeholder=" "
										aria-invalid={!!errors.username}
										className="peer pt-6"
										label="Username"
										{...register("username")}
									/>
								</div>
								{errors.username && (
									<FieldError>
										{errors.username.message}
									</FieldError>
								)}
							</Field>

							<Field data-invalid={!!errors.email}>
								<div className="relative">
									<InputLabel
										type="email"
										placeholder=" "
										aria-invalid={!!errors.email}
										className="peer pt-6"
										label="Email"
										{...register("email")}
									/>
								</div>
								{errors.email && (
									<FieldError>
										{errors.email.message}
									</FieldError>
								)}
							</Field>

							<Field data-invalid={!!errors.password}>
								<div className="relative">
									<InputLabel
										type="password"
										placeholder=" "
										aria-invalid={!!errors.password}
										className="peer pt-6"
										label="Password"
										{...register("password")}
									/>
								</div>
								{errors.password && (
									<FieldError>
										{errors.password.message}
									</FieldError>
								)}
							</Field>

							<Field data-invalid={!!errors.confirmPassword}>
								<div className="relative">
									<InputLabel
										type="password"
										placeholder=" "
										aria-invalid={!!errors.confirmPassword}
										className="peer pt-6"
										label="Confirm Password"
										{...register("confirmPassword")}
									/>
								</div>
								{errors.confirmPassword && (
									<FieldError>
										{errors.confirmPassword.message}
									</FieldError>
								)}
							</Field>
						</FieldGroup>

						<Button
							type="submit"
							className="bg-primary hover:bg-primary/90 h-12 w-full rounded-xl text-lg font-semibold text-white"
						>
							Create Account
						</Button>

						<div className="flex items-center justify-center gap-2 pt-4">
							<hr className="border-muted-foreground flex-1 border-t-2" />
							<span className="text-muted-foreground text-sm">
								Already have an account?
							</span>
							<Link
								href="/auth/login"
								className="hover:text-primary text-secondary-foreground text-sm font-semibold underline transition-colors duration-200"
							>
								Login
							</Link>
							<hr className="border-muted-foreground flex-1 border-t-2" />
						</div>
					</form>
				</div>
			</div>

			<AuthCard isRegister />
		</div>
	)
}
</file>

<file path="src/widgets/app-sidebar/ui/UserWidget.tsx">
import { userQueries } from "@/entities/user"
import { customToast } from "@/shared/lib/utils"
import { Avatar, AvatarFallback, AvatarImage } from "@/shared/ui/avatar"
import { Button } from "@/shared/ui/button"
import { Skeleton } from "@/shared/ui/skeleton"
import { LogOutIcon, User2Icon } from "lucide-react"
import { useRouter } from "next/navigation"

export default function UserWidget() {
	const { data, isLoading, error } = userQueries.useGetUser()
	const navigate = useRouter()
	const logoutUser = userQueries.useLogoutUser()

	return error && !data ? (
		<Button
			className="cursor-pointer"
			onClick={() => navigate.push("/auth/login")}
		>
			<User2Icon className="size-4" />
			<span className="font-montserrat text-md font-medium group-data-[collapsible=icon]:hidden group-data-[collapsible=icon]:p-0">
				Войти
			</span>
		</Button>
	) : (
		<div className="flex w-full items-center justify-between gap-4 border-t-2 border-white/10 p-3 group-data-[collapsible=icon]:justify-center">
			{!isLoading && data ? (
				<Avatar className="size-8 flex-shrink-0">
					<AvatarFallback className="bg-primary">
						{data?.username.slice(0, 2)}
					</AvatarFallback>
				</Avatar>
			) : (
				<Skeleton className="size-7" />
			)}
			{!isLoading && data ? (
				<div className="flex min-w-0 flex-1 flex-col justify-center group-data-[collapsible=icon]:hidden">
					<h3 className="truncate text-xs font-bold">
						{data?.username}
					</h3>
				</div>
			) : (
				<Skeleton className="h-4 w-full flex-1 rounded group-data-[collapsible=icon]:hidden" />
			)}
			<LogOutIcon
				onClick={() => {
					logoutUser.mutate(void 0, {
						onSuccess: () => {
							customToast("Logged out successfully", "success")
							navigate.push("/auth/login")
							navigate.refresh()
						},
					})
				}}
				className="block size-6 flex-shrink-0 cursor-pointer text-white transition-all duration-200 group-data-[collapsible=icon]:hidden hover:scale-105"
			/>
		</div>
	)
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next"

const nextConfig: NextConfig = {
	// ✅ Standalone режим для Docker (оптимизирует размер образа)
	output: "standalone",

	images: {
		remotePatterns: [
			{
				protocol: "https",
				hostname: "memology.pixel-team.ru",
			},
		],
		// ✅ Отключаем оптимизацию для dev режима (ускоряет разработку)
		unoptimized: process.env.NODE_ENV === "development",
	},

	// Прокси для API запросов (решает проблему с cookies в dev режиме)
	async rewrites() {
		if (process.env.NODE_ENV === "production") {
			return []
		}

		return [
			{
				source: "/api/v1/:path*",
				destination: "https://memology.pixel-team.ru/api/v1/:path*",
			},
		]
	},
}

export default nextConfig
</file>

<file path="package.json">
{
	"name": "ai-memes-frontend",
	"version": "0.1.0",
	"private": true,
	"scripts": {
		"dev": "next dev --turbopack",
		"build": "next build",
		"start": "next start --turbopack",
		"lint": "eslint",
		"generate:api": "openapi-typescript https://memology.pixel-team.ru/api/openapi.json -o src/shared/api/api-schema.d.ts",
		"generate:api:file": "openapi-typescript ./openapi.yaml -o src/shared/api/api-schema.d.ts",
		"docker:build": "docker-compose build",
		"docker:up": "docker-compose up -d",
		"docker:down": "docker-compose down",
		"docker:logs": "docker-compose logs -f",
		"docker:restart": "docker-compose restart",
		"docker:deploy": "docker-compose down && docker-compose build --no-cache && docker-compose up -d"
	},
	"dependencies": {
		"@hookform/resolvers": "^5.2.2",
		"@radix-ui/react-avatar": "^1.1.10",
		"@radix-ui/react-checkbox": "^1.3.3",
		"@radix-ui/react-dialog": "^1.1.15",
		"@radix-ui/react-label": "^2.1.7",
		"@radix-ui/react-scroll-area": "^1.2.10",
		"@radix-ui/react-select": "^2.2.6",
		"@radix-ui/react-separator": "^1.1.7",
		"@radix-ui/react-slot": "^1.2.3",
		"@radix-ui/react-tooltip": "^1.2.8",
		"@tanstack/react-query": "^5.90.2",
		"@tanstack/react-virtual": "^3.13.12",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"date-fns": "^4.1.0",
		"generator-swagger-2-ts": "^0.3.6",
		"image-size": "^2.0.2",
		"js-beautify": "^1.15.4",
		"lucide-react": "^0.544.0",
		"masonic": "^4.1.0",
		"neverthrow": "^8.2.0",
		"next": "^15",
		"next-themes": "^0.4.6",
		"nuqs": "^2.7.1",
		"openapi-fetch": "^0.15.0",
		"react": "19.1.0",
		"react-dom": "19.1.0",
		"react-hook-form": "^7.65.0",
		"react-plock": "^3.5.1",
		"react-virtualized": "^9.22.6",
		"sharp": "^0.34.4",
		"sonner": "^2.0.7",
		"tailwind-merge": "^3.3.1",
		"zod": "^4.1.12"
	},
	"devDependencies": {
		"@eslint/eslintrc": "^3",
		"@faker-js/faker": "^10.0.0",
		"@tailwindcss/postcss": "^4",
		"@tanstack/eslint-plugin-query": "^5.91.0",
		"@types/node": "^20",
		"@types/react": "^19",
		"@types/react-dom": "^19",
		"@types/react-virtualized": "^9.22.3",
		"eslint": "^9",
		"eslint-config-next": "15.5.4",
		"eslint-plugin-tailwindcss": "4.0.0-beta.0",
		"msw": "^2.11.3",
		"openapi-typescript": "^7.10.0",
		"prettier": "^3.6.2",
		"prettier-plugin-tailwindcss": "^0.6.14",
		"shadcn": "^3.5.0",
		"steiger": "^0.5.11",
		"swagger2openapi": "^7.0.8",
		"tailwindcss": "^4",
		"tw-animate-css": "^1.4.0",
		"typescript": "^5"
	},
	"msw": {
		"workerDirectory": [
			"public"
		]
	}
}
</file>

</files>
